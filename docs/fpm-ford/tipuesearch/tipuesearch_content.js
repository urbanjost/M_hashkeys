var tipuesearch = {"pages":[{"title":" M_hashkeys ","text":"M_hashkeys NOTE: This repository requires being built with fpm ( Fortran Package Manager )\n      Alternatively, it may be found as a part of the GPF( General Purpose Fortran ) NAME M_hashkeys - a collection of hash key generator modules DESCRIPTION M_hashkeys(3f) is a Fortran repository that contains several modules \n   of hash generators. DOCUMENTATION USER All documents are contained in the docs/ directory including\narchive files of man(1) pages that can be installed on ULS\n(Unix-Like Systems). Individual man-pages as HTML HTML versions of the man-pages describe all the routines:\n   - An index to M_hashkeys.f90 and M_sha3.f90 All man-pages amalgamated as HTML Another view of these documents (that uses javascript to combine all\n   the HTML descriptions of the man-pages) is in a form that can easily be printed as a single document.\n   - BOOK_M_hashkeys - BOOK_M_sha3 real man-pages manpages.zip manpages.tgz CHANGELOG provides a history of significant changes DEVELOPER doxygen(1) output . ford(1) output . github action status DOWNLOAD AND BUILD fpm Download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_hashkeys.git\n        cd M_hashkeys\n        fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_hashkeys = { git = \"https://github.com/urbanjost/M_hashkeys.git\" } — Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_sha3.f90 – M_hashkeys","text":"Contents Modules M_sha3 Source Code M_sha3.f90 Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== module M_sha3 !> !!##NAME !!    M_sha3(3fm) - [M_sha3::INTRO] a module implementing the SHA-3 hash function !!##SYNOPSIS !! !!   Procedures: !! !!     use M_sha3, only : sha3 !!     use M_sha3, only : sha3_update !!     use M_sha3, only : sha3_state !!     use M_sha3, only : sha3_digest !!     use M_sha3, only : sha3_hexdigest !!     use M_sha3, only : sha3_file !!     use M_sha3, only : sha3_auto_test !!##DESCRIPTION !!    This module implements the SHA-3 hash function, according to FIPS !!    PUB 202, SHA-3 Standard: Permutation-Based Hash and Extendable-Output !!    Functions, a NIST publication. !! !!    Originally based on routines from http://alcinoe.net/fortran.html !! !!    In this module, we focus on hashing strings of bytes (as opposed to !!    strings of bits whose length is not a multiple of 8). We also focus !!    on providing a fixed-length digest, rather than extendable output. For !!    us, bytes mean integers of kind 1. !! !!    There are two ways of using the module: !! !!      - a functional form, in which the whole array of bytes to hash !!        is passed to a function, which returns an array of bytes: !! !!           digest = sha3( buffer, d ) !! !!        where d is an integer (default kind) that specifies the digest !!        length in bits (so that 'digest' should have a size of d/8) !! !!      - a subroutine form, which is typically used like this: !! !!            type(sha3_state) :: S !!            call sha3_update( S, buffer1, d ) !!            call sha3_update( S, buffer2 ) !!            ... !!            call sha3_digest( S, digest ) !!        where you pass the data to hash little by little with !!        'sha3_update', and finish the process with 'sha3_digest' (after !!        you which can start anew with the same state) !! !!    According to the standard, the digest size d may be one of 224, 256, !!    384, 512, which results in arrays of bytes of size 28, 32, 48 and !!    64. These arrays of bytes can be converted into a hexadecimal string !!    of length 56, 64, 96 and 128 by calling the 'sha3_hexdigest' function: !! !!         hd = sha3_hexdigest( digest ) !! !!    If the data to hash is a string, one may convert it to an array of !!    bytes or integer(kind=int8) using the transfer intrinsic: !! !!       buffer = transfer( string, buffer ) !! !!    where size(buffer) = len(string) !! !!    The final routine exported by the module is sha3_auto_test(), which !!    hashes some test vectors, as found on: !! !!       http://www.di-mgt.com.au/sha_testvectors.html !! !!    and some files in the directory 'test_vectors', for which !!    the digest was found using the Python implementation from !! !!       https://github.com/gvanas/KeccakCodePackage. !! !!##EXAMPLE !! !!   Sample program !! !!    program demo_M_sha3 !!    use M_sha3 !!    implicit none !!    character(len=128) :: fname, arg !!       call get_command_argument( 1, arg ) !!       if ( arg(1:1) .eq. '-' ) then !!          if ( trim(arg) .eq. '-a' ) then !!             call sha3_auto_test() !!          else !!             call get_command_argument( 2, fname ) !!            select case(trim(arg)) !!            case('-224'); call sha3_file( 224, trim(fname) ) !!            case('-256'); call sha3_file( 256, trim(fname) ) !!            case('-384'); call sha3_file( 384, trim(fname) ) !!            case('-512'); call sha3_file( 512, trim(fname) ) !!            case default !!                print *,'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' !!            end select !!          endif !!       else !!          print *, 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' !!          print *, 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' !!       endif !! end program demo_M_sha3 use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 use M_strings , only : setbits8 implicit none private ! this is one set of parameters for Keccak (standard one for SHA-3) ! with this set of parameters, a lane is encoded with an integer(8) (64 bits) integer , parameter :: LANE = 8 integer , parameter :: W = 64 integer , parameter :: ELL = 6 integer ( kind = int64 ), dimension ( 5 , 5 ) :: sbuf ! pre-computed values of the RC parameter in function iota integer ( kind = int64 ), save , dimension ( 24 ) :: RC_C !integer(kind=int64),parameter,dimension(24) :: RC_C = [ & !int(z'8000000000000000',kind=int64), & !int(z'4101000000000000',kind=int64), & !int(z'5101000000000001',kind=int64), & !int(z'0001000100000001',kind=int64), & !int(z'D101000000000000',kind=int64), & !int(z'8000000100000000',kind=int64), & !int(z'8101000100000001',kind=int64), & !int(z'9001000000000001',kind=int64), & !int(z'5100000000000000',kind=int64), & !int(z'1100000000000000',kind=int64), & !int(z'9001000100000000',kind=int64), & !int(z'5000000100000000',kind=int64), & !int(z'D101000100000000',kind=int64), & !int(z'D100000000000001',kind=int64), & !int(z'9101000000000001',kind=int64), & !int(z'C001000000000001',kind=int64), & !int(z'4001000000000001',kind=int64), & !int(z'0100000000000001',kind=int64), & !int(z'5001000000000000',kind=int64), & !int(z'5000000100000001',kind=int64), & !int(z'8101000100000001',kind=int64), & !int(z'0101000000000001',kind=int64), & !int(z'8000000100000000',kind=int64), & !int(z'1001000100000001',kind=int64) ] !transfer(z'8000000000000000',0_int64), & !transfer(z'4101000000000000',0_int64), & !transfer(z'5101000000000001',0_int64), & !transfer(z'0001000100000001',0_int64), & !transfer(z'D101000000000000',0_int64), & !transfer(z'8000000100000000',0_int64), & !transfer(z'8101000100000001',0_int64), & !transfer(z'9001000000000001',0_int64), & !transfer(z'5100000000000000',0_int64), & !transfer(z'1100000000000000',0_int64), & !transfer(z'9001000100000000',0_int64), & !transfer(z'5000000100000000',0_int64), & !transfer(z'D101000100000000',0_int64), & !transfer(z'D100000000000001',0_int64), & !transfer(z'9101000000000001',0_int64), & !transfer(z'C001000000000001',0_int64), & !transfer(z'4001000000000001',0_int64), & !transfer(z'0100000000000001',0_int64), & !transfer(z'5001000000000000',0_int64), & !transfer(z'5000000100000001',0_int64), & !transfer(z'8101000100000001',0_int64), & !transfer(z'0101000000000001',0_int64), & !transfer(z'8000000100000000',0_int64), & !transfer(z'1001000100000001',0_int64) ] type sha3_state integer :: d ! size of digest in bits integer :: c ! capacity in bits integer :: r ! rate, in bits integer ( kind = int64 ), dimension ( 5 , 5 ) :: S ! state integer ( kind = int8 ), dimension (:), pointer :: buffer integer :: bufsize = - 1 ! the number of bytes actually usable in buffer end type sha3_state public :: sha3 , sha3_update , sha3_state , sha3_digest , sha3_hexdigest , sha3_file , sha3_auto_test public test_suite_M_sha3 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_file ( d , fname , hdigest ) ! hashes a file and either returns the sha3_hexdigest in a string, or display it to ! stdout, along with the file name. d is the digest size in bits (224,256,384,512) use M_system , only : system_stat integer , intent ( in ) :: d character ( len =* ), intent ( in ) :: fname character ( len =* ), optional , intent ( out ) :: hdigest integer ( kind = int8 ), dimension ( d / 8 ) :: digest logical :: fexist integer :: fsize , i , j , nread , nrem type ( sha3_state ) :: S integer ( kind = int8 ), dimension (:), allocatable :: buffer integer ( kind = int64 ), dimension ( 13 ) :: values character ( len = 128 ) :: dg ! does this file exist? if yes, what is its size? inquire ( file = trim ( adjustl ( fname )), exist = fexist ) if ( . not . fexist ) then print * , 'file not found.' return endif call system_stat ( trim ( fname ), values ) fsize = int ( values ( 8 )) ! read the file into a buffer with the appropriate size allocate ( buffer ( 4096 ) ) open ( unit = 39 , file = trim ( adjustl ( fname )), form = 'unformatted' , access = 'direct' , recl = 1 ) nrem = fsize j = 0 do nread = min ( nrem , 4096 ) do i = 1 , nread j = j + 1 read ( 39 , rec = j ) buffer ( i ) enddo if ( nread == 4096 ) then call sha3_update ( S , buffer , d ) else call sha3_update ( S , buffer ( 1 : nread ), d ) endif nrem = nrem - nread if ( nrem <= 0 ) exit enddo close ( 39 ) call sha3_digest ( S , digest ) dg = sha3_hexdigest ( digest ) if ( present ( hdigest ) ) then hdigest = trim ( dg ) else print '(3a)' , trim ( dg ), ' ' , trim ( fname ) endif deallocate ( buffer ) end subroutine sha3_file !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_hexdigest ( d ) ! returns a digest d (a list of bytes) as an hexadecimal string integer ( kind = int8 ), dimension (:), intent ( in ) :: d character ( len = size ( d ) * 2 ) :: sha3_hexdigest write ( sha3_hexdigest , '(100Z2.2)' ) d end function sha3_hexdigest !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_update ( state , buffer , d ) ! this routine type ( sha3_state ), intent ( inout ) :: state integer ( kind = int8 ), dimension (:), intent ( in ) :: buffer integer , optional , intent ( in ) :: d integer , save :: r8 integer :: j if ( state % bufsize == - 1 ) then ! means we never, ever called sha3_update before, and thus the buffer pointer ! in state is in limbo nullify ( state % buffer ) endif if ( state % bufsize < 0 ) then ! means that we start working on a new input if ( present ( d ) ) then state % d = d else state % d = 224 endif if ( state % d == 224 ) then state % c = 448 elseif ( state % d == 256 ) then state % c = 512 elseif ( state % d == 384 ) then state % c = 768 elseif ( state % d == 512 ) then state % c = 1024 else ! todo endif state % r = 25 * W - state % c ! initialize state state % S = 0_int64 allocate ( state % buffer ( state % r / 4 ) ) state % bufsize = 0 ! buffer allocated, but empty r8 = state % r / 8 endif ! in case there was data left in the *state* buffer from a previous call ! to sha3_update, we append the received data to it if ( state % bufsize > 0 ) then ! complete the state buffer j = min ( size ( buffer ), r8 - state % bufsize ) ! how many bytes from buffer to use state % buffer ( state % bufsize + 1 : state % bufsize + j ) = buffer ( 1 : j ) state % bufsize = state % bufsize + j if ( state % bufsize >= r8 ) then call sha3_block ( state % S , state % buffer ( 1 : r8 ), r8 ) state % bufsize = 0 ! hash the remainder of the data (if any) do if ( j + r8 >= size ( buffer ) ) exit ! hash this block, w call sha3_block ( state % S , buffer ( j + 1 : j + r8 ), r8 ) ! go to next input block j = j + r8 enddo else return endif else ! hash what we can from buffer j = 0 do if ( j + r8 >= size ( buffer ) ) exit ! hash this block, w call sha3_block ( state % S , buffer ( j + 1 : j + r8 ), r8 ) ! go to next input block j = j + r8 enddo endif ! add the remainder to state%buffer: ! just accumulate data, because this cannot be hashed without taking ! padding into account if ( state % bufsize + ( size ( buffer ) - j ) > size ( state % buffer ) ) then print * , 'error, buffer is too small ???' else state % buffer ( state % bufsize + 1 : state % bufsize + size ( buffer ) - j ) = buffer ( j + 1 : size ( buffer ) ) state % bufsize = state % bufsize + size ( buffer ) - j if ( state % bufsize < 0 ) print * , 'error, buffer size < 0' endif ! is buffer large enough to process a block ? if ( state % bufsize >= r8 ) then call sha3_block ( state % S , state % buffer ( 1 : r8 ), r8 ) ! \"resize\" buffer state % buffer ( 1 : state % bufsize - r8 ) = state % buffer ( r8 + 1 : state % bufsize ) state % bufsize = state % bufsize - r8 endif end subroutine sha3_update !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_block ( S , buffer , r8 ) ! given a state matrix S, a full buffer of bytes (i.e., r8 bytes), this routine ! absorbs the content of buffer into the sponge. integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: S integer ( kind = int8 ), dimension (:), intent ( in ) :: buffer integer , intent ( in ) :: r8 integer :: i , k , a , b integer ( kind = int8 ), dimension ( LANE ) :: bytes a = 1 ; b = 1 do i = 1 , r8 / LANE ! loop on each lane do k = 1 , LANE ! revert the bytes in each lane bytes ( 9 - k ) = sha3_reverse ( buffer (( i - 1 ) * 8 + k ) ) enddo ! XOR the message with state S ( a , b ) = ieor ( S ( a , b ), transfer ( bytes , S ( a , b ) ) ) a = a + 1 if ( a == 6 ) then a = 1 ; b = b + 1 endif enddo ! apply the sha3_keccak_p function on the state do i = 2 * ELL + 12 - ( 2 * ELL + 12 ), 2 * ELL + 12 - 1 call sha3_round ( S , i ) enddo end subroutine sha3_block !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_digest ( state , digest ) type ( sha3_state ), intent ( inout ) :: state integer ( kind = int8 ), dimension (:), intent ( out ) :: digest integer ( kind = int8 ) :: bug integer :: i , j integer ( kind = int8 ), dimension ( 25 * LANE ) :: string ! it remains to apply padding the the current buffer, add this to sponge ! apply keccak, and squeeze ! the problem may be that, depending on the size of the buffer, we may have ! one or two r-bits blocks after padding digest = 0_int8 ! proceed to padding. in here, we know that bufsize is strictly less than r/8 bytes ! (contrary to the sha3 function) i = mod ( state % bufsize + 1 , state % r / 8 ) ! how many bytes to add if ( i == 0 ) then ! just add one byte for padding, and we have a full block ready to hash !>>>>>>>>>>>> !*!GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b'10000110',kind=int8),state%buffer(1)) bug = setbits8 ( '10000110' ) state % buffer ( state % r / 8 ) = transfer ( bug , state % buffer ( 1 )) !<<<<<<<<<<<< else state % buffer ( state % bufsize + 1 ) = transfer ( int ( b '00000110' , kind = int8 ), state % buffer ( 1 )) state % buffer ( state % bufsize + 2 : state % r / 8 - 1 ) = 0_int8 !>>>>>>>>>>>> !*!GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b'10000000',kind=int8),state%buffer(1)) bug = setbits8 ( '10000000' ) state % buffer ( state % r / 8 ) = transfer ( bug , state % buffer ( 1 )) !<<<<<<<<<<<< endif ! absorb this last block... call sha3_block ( state % S , state % buffer ( 1 : state % r / 8 ), state % r / 8 ) ! ...and squeeze if ( state % d < state % r ) then ! go back from state matrix to string string = sha3_state2string2 ( state % S , 25 * W / 8 ) digest = string ( 1 : state % d / 8 ) do i = 1 , state % d / 8 digest ( i ) = sha3_reverse ( digest ( i )) enddo else j = 0 ! number of bytes currently outputted !!$     do !!$        i = min( r/8, d/8 - j ) !!$        sha3_sponge(j+1:j+i) = S(1:i) ! get r bits from state !!$        j = j + i ! update the number of bytes outputted !!$        ! exit when we have enough !!$        if ( j >= d/8 ) exit !!$        ! otherwise, continue squeezing !!$        S = sha3_keccak_p( S, 25*W, 2*ELL+12 ) !!$     enddo endif ! once the digest has been provide, there are some tasks to perform ! (reinit the state and deallocation) deallocate ( state % buffer ) nullify ( state % buffer ) state % bufsize = - 1 end subroutine sha3_digest !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3 ( buffer , d ) ! SHA3 can produce variable-length digests, having length d in bits ! we assume that d is a multiple of 8 integer ( kind = int8 ), dimension (:), intent ( in ) :: buffer integer , intent ( in ) :: d ! output length integer ( kind = int8 ), dimension ( d / 8 ) :: sha3 select case ( d ) case ( 224 ) ! SHA3 224 sha3 = sha3_keccak ( buffer , 224 , 448 ) case ( 256 ) ! SHA3 256 sha3 = sha3_keccak ( buffer , 256 , 512 ) case ( 384 ) ! SHA3 384 sha3 = sha3_keccak ( buffer , 384 , 768 ) case ( 512 ) ! SHA3 512 sha3 = sha3_keccak ( buffer , 512 , 1024 ) case default if ( d > 0 ) then sha3 = sha3_keccak ( buffer , d , 256 ) else sha3 = sha3_keccak ( buffer , - d , 512 ) endif end select end function sha3 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_keccak ( M , d , c ) integer ( kind = int8 ), dimension (:), intent ( in ) :: M integer , intent ( in ) :: d ! output length of digest integer , intent ( in ) :: c ! capacity (distinguishes variants of K) integer ( kind = int8 ), dimension ( d / 8 ) :: sha3_keccak ! here, M should have been padded with '1111' in XOF mode, '01' otherwise sha3_keccak = sha3_sponge ( M , d , 25 * W - c ) end function sha3_keccak !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_sponge ( M , d , r ) integer ( kind = int8 ), dimension (:), intent ( in ) :: M integer , intent ( in ) :: d ! output length of digest integer , intent ( in ) :: r ! rate integer ( kind = int8 ), dimension ( d / 8 ) :: sha3_sponge integer :: i , c , n , j , k integer ( kind = int8 ), dimension ( 25 * LANE ) :: S ! state, as a string integer ( kind = int8 ), dimension ( r / 8 ) :: padding ! capacity is b - rate c = 25 * W - r n = 0 ! 0. PADDING------------------------------------------------------ ! our goal is to determine 'padding', which is an array of r/8 bytes ! that contains the end of the message M plus the required padding if ( d == 224 . or . d == 256 . or . d == 384 . or . d == 512 ) then ! classic hashing: append '01', plus Pad10*1, such that message ! length (in bits) is a multiple of r, or rather, for us, such that ! message length in bytes is a multiple of r/8 i = mod ( size ( M ) + 1 , r / 8 ) ! how many bytes to add if ( i > 0 ) i = r / 8 - i if ( i == 0 ) then ! it is ok to add just one byte do j = 1 , r / 8 - 1 padding ( j ) = sha3_reverse ( M ( size ( M ) - ( r / 8 - 1 ) + j ) ) enddo padding ( r / 8 ) = transfer ( int ( b '01100001' , kind = int8 ), padding ( 1 )) n = ( size ( M ) - ( r / 8 - 1 )) / ( r / 8 ) else padding = 0_int8 do j = 1 , r / 8 - 1 - i padding ( j ) = sha3_reverse ( M ( size ( M ) - ( r / 8 - 1 - i ) + j ) ) enddo padding ( r / 8 - i ) = transfer ( int ( b '01100000' , kind = int8 ), padding ( 1 )) padding ( r / 8 ) = transfer ( int ( b '00000001' , kind = int8 ), padding ( 1 )) n = ( size ( M ) - ( r / 8 - 1 - i )) / ( r / 8 ) endif else ! XOF mode: append '1111', plus Pad10*1 !TODO endif ! n is the number of r-bits = r/8 bytes blocks in the message that are ! not affected by padding. For short messages, n = 0, because the message ! *with* padding fits in a single r-bits block (block \"padding\") j = 0 ! indices the sub-block of M that is treated S = 0_int8 ! state starts initially full of 0 if ( n == 0 ) then ! message is sufficiently short to be fully inside padding ! initial XOR'd state do k = 1 , r / 8 S ( k ) = ieor ( S ( k ), padding ( k ) ) enddo else ! 1. ABSORBING---------------------------------------------------- do i = 1 , n ! xor S and the next block of input to hash (byte by byte) do k = 1 , r / 8 S ( k ) = ieor ( S ( k ), sha3_reverse ( M ( j + k ) ) ) enddo ! for the remainder of S, it is xor'd with 0, i.e., unchanged j = j + r / 8 S = sha3_keccak_p ( S , 25 * W , 2 * ELL + 12 ) enddo ! the last block has in general been padded (this last block may be the first!!) do k = 1 , r / 8 S ( k ) = ieor ( S ( k ), padding ( k ) ) enddo endif ! this is the last S = sha3_keccak_p ( S , 25 * W , 2 * ELL + 12 ) ! 2. SQUEEZING--------------------------------------------------- if ( d < r ) then sha3_sponge = S ( 1 : d / 8 ) else j = 0 ! number of bytes currently outputted do i = min ( r / 8 , d / 8 - j ) sha3_sponge ( j + 1 : j + i ) = S ( 1 : i ) ! get r bits from state j = j + i ! update the number of bytes outputted ! exit when we have enough if ( j >= d / 8 ) exit ! otherwise, continue squeezing S = sha3_keccak_p ( S , 25 * W , 2 * ELL + 12 ) enddo endif ! reverse the bytes we output do i = 1 , d / 8 sha3_sponge ( i ) = sha3_reverse ( sha3_sponge ( i ) ) enddo !print '(a,100(z2.2))', 'sponge = ', sha3_sponge end function sha3_sponge !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_keccak_p ( S , b , nr ) integer ( kind = int8 ), dimension (:), intent ( in ) :: S ! input \"string\" integer , intent ( in ) :: b ! size of input, in bits integer , intent ( in ) :: nr ! number of rounds integer ( kind = int8 ), dimension ( b / 8 ) :: sha3_keccak_p integer ( kind = int64 ), dimension ( 5 , 5 ) :: state integer :: ir ! convert S to state state = sha3_string2state ( S ) ! perform rounds do ir = 2 * ELL + 12 - nr , 2 * ELL + 12 - 1 call sha3_round ( state , ir ) enddo ! convert from state to string sha3_keccak_p = sha3_state2string2 ( state , b / 8 ) end function sha3_keccak_p !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_round ( state , round_index ) integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: state integer , intent ( in ) :: round_index logical , save :: initialized = . false . if (. not . initialized ) then initialized = . true . INITIALIZE : block integer :: i character ( len = 16 ), parameter :: strings ( * ) = [ & '8000000000000000' , '4101000000000000' , '5101000000000001' , '0001000100000001' , 'D101000000000000' , '8000000100000000' , & '8101000100000001' , '9001000000000001' , '5100000000000000' , '1100000000000000' , '9001000100000000' , '5000000100000000' , & 'D101000100000000' , 'D100000000000001' , '9101000000000001' , 'C001000000000001' , '4001000000000001' , '0100000000000001' , & '5001000000000000' , '5000000100000001' , '8101000100000001' , '0101000000000001' , '8000000100000000' , '1001000100000001' ] character ( len = 16 ) :: readme do i = 1 , size ( RC_C ) readme = strings ( i ) read ( readme , '(z16)' ) RC_C ( i ) enddo end block INITIALIZE endif ! the five steps of a round are made of the theta, rho, pi, khi and iota steps call sha3_theta ( state ) call sha3_rho ( state ) call sha3_pi ( state ) call sha3_khi ( state ) ! iota is simple, no need to call a function for that state ( 1 , 1 ) = ieor ( state ( 1 , 1 ), RC_C ( round_index + 1 ) ) end subroutine sha3_round !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_theta ( A ) integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: A integer ( kind = int64 ), dimension ( 5 ) :: C , D integer :: x , y do x = 1 , 5 C ( x ) = ieor ( A ( x , 1 ), ieor ( A ( x , 2 ), ieor ( A ( x , 3 ), ieor ( A ( x , 4 ), A ( x , 5 ) ) ) ) ) enddo D ( 1 ) = ieor ( C ( 5 ), ishftc ( C ( 2 ), - 1 ) ) D ( 2 ) = ieor ( C ( 1 ), ishftc ( C ( 3 ), - 1 ) ) D ( 3 ) = ieor ( C ( 2 ), ishftc ( C ( 4 ), - 1 ) ) D ( 4 ) = ieor ( C ( 3 ), ishftc ( C ( 5 ), - 1 ) ) D ( 5 ) = ieor ( C ( 4 ), ishftc ( C ( 1 ), - 1 ) ) do y = 1 , 5 do x = 1 , 5 A ( x , y ) = ieor ( A ( x , y ), D ( x ) ) enddo enddo end subroutine sha3_theta !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_rho ( A ) integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: A integer :: x , y , z , t x = 1 ; y = 0 do t = 0 , 23 z = ( t + 1 ) * ( t + 2 ) / 2 A ( x + 1 , y + 1 ) = ishftc ( A ( x + 1 , y + 1 ), - mod ( z , 64 ) ) z = y y = mod ( 2 * x + 3 * y , 5 ) x = z enddo end subroutine sha3_rho !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_pi ( A ) integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: A integer ( kind = int64 ) :: t t = A ( 4 , 4 ) A ( 4 , 4 ) = A ( 3 , 4 ) A ( 3 , 4 ) = A ( 2 , 3 ) A ( 2 , 3 ) = A ( 3 , 2 ) A ( 3 , 2 ) = A ( 1 , 3 ) A ( 1 , 3 ) = A ( 2 , 1 ) A ( 2 , 1 ) = A ( 2 , 2 ) A ( 2 , 2 ) = A ( 5 , 2 ) A ( 5 , 2 ) = A ( 3 , 5 ) A ( 3 , 5 ) = A ( 5 , 3 ) A ( 5 , 3 ) = A ( 1 , 5 ) A ( 1 , 5 ) = A ( 3 , 1 ) A ( 3 , 1 ) = A ( 3 , 3 ) A ( 3 , 3 ) = A ( 4 , 3 ) A ( 4 , 3 ) = A ( 5 , 4 ) A ( 5 , 4 ) = A ( 4 , 5 ) A ( 4 , 5 ) = A ( 1 , 4 ) A ( 1 , 4 ) = A ( 5 , 1 ) A ( 5 , 1 ) = A ( 5 , 5 ) A ( 5 , 5 ) = A ( 2 , 5 ) A ( 2 , 5 ) = A ( 4 , 2 ) A ( 4 , 2 ) = A ( 2 , 4 ) A ( 2 , 4 ) = A ( 1 , 2 ) A ( 1 , 2 ) = A ( 4 , 1 ) A ( 4 , 1 ) = t end subroutine sha3_pi !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_khi ( A ) integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( inout ) :: A integer :: x , y , x1 , x2 sbuf = A do x = 1 , 5 x1 = x + 1 if ( x == 5 ) x1 = 1 x2 = x + 2 if ( x2 > 5 ) x2 = x2 - 5 do y = 1 , 5 A ( x , y ) = ieor ( sbuf ( x , y ), iand ( not ( sbuf ( x1 , y ) ), sbuf ( x2 , y ) ) ) enddo enddo end subroutine sha3_khi !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_reverse ( b ) ! reverses the order of the bits in byte b integer ( kind = int8 ), intent ( in ) :: b integer ( kind = int8 ) :: sha3_reverse !*!<<<<<<<<<<<<<<<<<<< !*!  BUG: GNU Fortran (GCC) 8.3.1 20191121 (Red Hat 8.3.1-5) !*!  integer(kind=int8),parameter :: Z0F=int(z'0F',kind=int8), & !*!                          Z33=int(z'33',kind=int8), & !*!                          Z55=int(z'55',kind=int8), & !*!                          ZAA=int(z'AA',kind=int8), & !*!                          ZCC=int(z'CC',kind=int8), & !*!                          ZF0=int(z'F0',kind=int8) !*!=================== logical , save :: setup = . false . character ( len = 2 ) :: num integer ( kind = int8 ), save :: Z0F , Z33 , Z55 , ZAA , ZCC , ZF0 if (. not . setup ) then num = '0F' ; read ( num , '(z2)' ) Z0F num = '33' ; read ( num , '(z2)' ) Z33 num = '55' ; read ( num , '(z2)' ) Z55 num = 'AA' ; read ( num , '(z2)' ) ZAA num = 'CC' ; read ( num , '(z2)' ) ZCC num = 'F0' ; read ( num , '(z2)' ) ZF0 setup = . true . endif !*!>>>>>>>>>>>>>>>>>>> sha3_reverse = ior ( ishft ( iand ( b , zF0 ), - 4 ), ishft ( iand ( b , z0F ), 4 ) ) sha3_reverse = ior ( ishft ( iand ( sha3_reverse , zCC ), - 2 ), ishft ( iand ( sha3_reverse , z33 ), 2 ) ) sha3_reverse = ior ( ishft ( iand ( sha3_reverse , zAA ), - 1 ), ishft ( iand ( sha3_reverse , z55 ), 1 ) ) end function sha3_reverse !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_string2state ( S ) ! an input string is (in principle) as string of bits of length b, but always ! encoded as an array of bytes (b/8 bytes) ! w/8 consecutive bytes form a lane, and lanes are stored in a state matrix ! in the order  A(1,1)  A(2,1)  A(3,1)  A(4,1)  A(5,1)   A(1,2) ... A(5,5) integer ( kind = int8 ), dimension (:), intent ( in ) :: S ! input \"string\" as a list of bytes integer ( kind = int64 ), dimension ( 5 , 5 ) :: sha3_string2state integer ( kind = int8 ), dimension ( 8 ) :: reve integer :: x , y , z , i z = 0 do y = 1 , 5 do x = 1 , 5 do i = 1 , 8 reve ( 9 - i ) = S ( z + i ) enddo sha3_string2state ( x , y ) = transfer ( reve , sha3_string2state ( x , y ) ) z = z + LANE enddo enddo end function sha3_string2state !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha3_state2string2 ( S , sz ) ! convert a state S to a string (array) of sz bytes integer , intent ( in ) :: sz integer ( kind = int64 ), dimension ( 5 , 5 ), intent ( in ) :: S integer ( kind = int8 ), dimension ( sz ) :: sha3_state2string2 ! input \"string\" as a list of bytes integer ( kind = int8 ), dimension ( 8 ) :: bytes integer :: x , y , z , i ! convert S to state z = LANE + 1 do y = 1 , 5 do x = 1 , 5 bytes ( 1 : 8 ) = transfer ( S ( x , y ), bytes ( 1 : 8 ) ) do i = 1 , 8 sha3_state2string2 ( z - i ) = bytes ( i ) enddo z = z + LANE enddo enddo end function sha3_state2string2 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine sha3_auto_test () !call sha3_test11() call sha3_test21 () call sha3_test31 () call sha3_test41 () call sha3_test51 () call sha3_test61 () contains !================================================================================ subroutine sha3_test11 () !================================================================================ integer ( kind = int8 ), dimension ( 512 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST11  : hash empty string' print '(a,a128)' , '         ' , sha3_hexdigest ( sha3 ( buffer , 512 )) allocate ( buffer ( 0 ) ) call sha3_update ( S , buffer , 512 ) call sha3_digest ( S , digest ) print '(a,a128)' , '         ' , sha3_hexdigest ( digest ) print '(a,2a128)' , '         A69F73CCA23A9AC5C8B567DC185A756E97C982164FE25859E0D1DCC1475C80' , & 'A615B2123AF1F5F94C11E3E9402C3AC558F500199D95B6D3E301758586281DCD26' end subroutine sha3_test11 !================================================================================ subroutine sha3_test21 () !================================================================================ character ( len = 1024 ) :: m integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST21  : hash \"abc\"' m = 'abc' allocate ( buffer ( len_trim ( m )) ) buffer = transfer ( trim ( m ), buffer ) print * , '        ' , sha3_hexdigest ( sha3 ( buffer , 224 ) ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) print * , '        ' , sha3_hexdigest ( digest ) print * , '        E642824C3F8CF24AD09234EE7D3C766FC9A3A5168D0C94AD73B46FDF' deallocate ( buffer ) end subroutine sha3_test21 !================================================================================ subroutine sha3_test31 () !================================================================================ character ( len = 1024 ) :: m integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST31  : hash \"abc...stu\"' m = 'abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu' allocate ( buffer ( len_trim ( m )) ) buffer = transfer ( trim ( m ), buffer ) print * , '        ' , sha3_hexdigest ( sha3 ( buffer , 224 ) ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) print * , '        ' , sha3_hexdigest ( digest ) print * , '        543E6868E1666C1A643630DF77367AE5A62A85070A51C14CBF665CBC' deallocate ( buffer ) end subroutine sha3_test31 !================================================================================ subroutine sha3_test41 () !================================================================================ integer , parameter :: N = 1000 * 1000 integer , parameter :: M = 100 integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S integer :: i , j real :: t1 , t2 , d1 , d2 , d3 print * print * , 'TEST41  : hash \"a\"*' , N allocate ( buffer ( N ) ) do i = 1 , N buffer ( i ) = 97_int8 enddo call cpu_time ( t1 ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) call cpu_time ( t2 ) d1 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) call cpu_time ( t1 ) digest = sha3 ( buffer , 224 ) call cpu_time ( t2 ) d2 = t2 - t1 ! now provide it in small packets call cpu_time ( t1 ) j = 0 do i = 1 , N / M call sha3_update ( S , buffer ( j + 1 : j + M ) ) j = j + M enddo call sha3_digest ( S , digest ) call cpu_time ( t2 ) d3 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) print * , '        D69335B93325192E516A912E6D19A15CB51C6ED5C15243E7A7FD653C' deallocate ( buffer ) !print *, 'timings: ', d1, d2, d3 !call sha3_file( 'sha3.f90', 224, digest ) end subroutine sha3_test41 !================================================================================ subroutine sha3_test51 () !================================================================================ integer :: i , j character ( len = 128 ) :: digest , fname , fname2 character ( len = 256 ) :: line integer , dimension ( 4 ) :: dv , mds dv = ( / 224 , 256 , 384 , 512 / ) mds = ( / 56 , 64 , 96 , 128 / ) print * print * , 'TEST 51 : hash files and compare digests with reference' ! loop on test vectors do i = 1 , 5 write ( fname2 , '(a,i3.3,a)' ) 'test_vectors/test_' , i , '.digests' open ( unit = 12 , file = trim ( fname2 ) ) print * , '   file #' , i ! loop on SHA3 variant do j = 1 , 4 write ( fname , '(a,i3.3,a)' ) 'test_vectors/test_' , i , '.msg' call sha3_file ( dv ( j ), fname , digest ) write ( * , '(10x,i3,1x,a)' ) dv ( j ), trim ( digest ) read ( 12 , '(a)' ) line write ( * , '(10x,a)' ) trim ( line ) print * enddo close ( 12 ) print * enddo end subroutine sha3_test51 !================================================================================ subroutine sha3_test61 () !================================================================================ integer , parameter :: N = 100 * 1024 * 1024 integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S integer :: i real :: t1 , t2 , d1 print * print * , 'TEST61  : speed test (hash 100 MiB)' allocate ( buffer ( N ) ) do i = 1 , N buffer ( i ) = 97_int8 enddo call cpu_time ( t1 ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) call cpu_time ( t2 ) d1 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) print * , 'timings: ' , d1 , 's' deallocate ( buffer ) end subroutine sha3_test61 end subroutine sha3_auto_test !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== subroutine test_suite_M_sha3 () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level !! setup call test_sha3 () call test_sha3_auto_test () call test_sha3_digest () call test_sha3_file () call test_sha3_hexdigest () call test_sha3_update () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3 () call unit_check_start ( 'sha3' , msg = '' ) !!call unit_check('sha3', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3' , msg = '' ) end subroutine test_sha3 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_auto_test () call unit_check_start ( 'sha3_auto_test' , msg = '' ) !!call unit_check('sha3_auto_test', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_auto_test' , msg = '' ) end subroutine test_sha3_auto_test !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_digest () call unit_check_start ( 'sha3_digest' , msg = '' ) !!call unit_check('sha3_digest', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_digest' , msg = '' ) end subroutine test_sha3_digest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_file () call unit_check_start ( 'sha3_file' , msg = '' ) !!call unit_check('sha3_file', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_file' , msg = '' ) end subroutine test_sha3_file !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_hexdigest () call unit_check_start ( 'sha3_hexdigest' , msg = '' ) !!call unit_check('sha3_hexdigest', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_hexdigest' , msg = '' ) end subroutine test_sha3_hexdigest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_update () call unit_check_start ( 'sha3_update' , msg = '' ) !!call unit_check('sha3_update', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_update' , msg = '' ) end subroutine test_sha3_update !=================================================================================================================================== end subroutine test_suite_M_sha3 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_sha3 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !===================================================================================================================================","tags":"","loc":"sourcefile/m_sha3.f90.html"},{"title":"M_hashkeys.F90 – M_hashkeys","text":"Contents Modules M_hashkeys Source Code M_hashkeys.F90 Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_hashkeys use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use , intrinsic :: iso_c_binding !!use,intrinsic :: iso_c_binding,   only : c_int32_t implicit none integer , parameter :: int128 = selected_real_kind ( 1 * precision ( 1.0_int64 )) ! THIS WAS BUILT ASSUMING NO REAL INT128 VARIABLE IS SUPPORTED ! ANYWHERE WHERE THIS IS USED WILL NOT WORK IDEALLY BECAUSE FORTRAN ! DOES NOT SUPPORT UNSIGNED INTEGERS !!integer,parameter :: int128 = selected_real_kind(2*precision(1.0_int64)) private ! key hash public b3hs_hash_key_jenkins ! cyclic redundancy check public crc32_hash interface crc32_hash module procedure crc32_hash_arr module procedure crc32_hash_scalar end interface crc32_hash ! ! string hashes ! ! bucket hash public int128 public djb2 public djb2_hash ! this string hash algorithm written in C was first reported by Dan J. Bernstein many years ago in comp.lang.c. interface djb2_hash module procedure djb2_hash_arr module procedure djb2_hash_scalar end interface djb2_hash public sdbm_hash interface sdbm_hash module procedure sdbm_hash_arr module procedure sdbm_hash_scalar end interface sdbm_hash interface anything_to_bytes module procedure anything_to_bytes_arr module procedure anything_to_bytes_scalar end interface anything_to_bytes logical , save :: debug = . false . integer , parameter :: dp = kind ( 0.0d0 ) ! WARNING: because there is currently no unsigned INTEGER in standard Fortran, use 128-bit INTEGER, which is not always available ! WARNING: not tested, but almost certainly get different results with different Endians !----------------------------------------------------------------------------------------------------------------------------------- public luhn_checksum !----------------------------------------------------------------------------------------------------------------------------------- ! Defines the public interface for sha256 public sha256 public dirty_sha256 ! Public for the sake of unit-testing. public test_suite_sha256 public test_suite_M_hashkeys private sha256b private ms0 private ms1 private cs0 private cs1 private maj private ch private swap32 private swap64 private swap64a private consume_chunk !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !! !!    For the sha256 and dirty_sha256 procedures and supporting private routines: !! !!    Copyright (c) 2014 Mikael Leetmaa !! !!    This software is provided 'as-is', without any express or implied !!    warranty. In no event will the authors be held liable for any damages !!    arising from the use of this software. !! !!    Permission is granted to anyone to use this software for any purpose, !!    including commercial applications, and to alter it and redistribute it !!    freely, subject to the following restrictions: !! !!       1. The origin of this software must not be misrepresented; you must not !!          claim that you wrote the original software. If you use this software !!          in a product, an acknowledgment in the product documentation would be !!          appreciated but is not required. !! !!       2. Altered source versions must be plainly marked as such, and must not be !!          misrepresented as being the original software. !! !!       3. This notice may not be removed or altered from any source !!          distribution. !> !!##NAME !!    sha256(3f) - [M_hashkeys] generate a SHA-256 hashing !! !!##SYNOPSIS !! !!   function sha256(str) !! !!    character(len=64)            :: sha256 !!    character(len=*), intent(in) :: str !! !!##DESCRIPTION !! !!    A Fortran module for SHA-256 hashing. !! !!    Note that this code will not produce the same results on big-endian !!    machines and the module was only tested on a little-endian Ubuntu LTS !!    12.04 system using gfortran 4.6.3. !! !!##OPTIONS !!    str      The message to digest. !! !!##RETURNS !!    sha256   The SHA-256 digest as a string of length 64. !! !!##COMPILE NOTES !! !!    The '-fno-range-check' flag is required on gfortran(1) since the !!    Fortran standard otherwise doesn't currently allow us to work with !!    all bits in the integers (as if they were unsigned). !! !!##AUTHOR !! !!    This routine is heavily based on the SHA-256 routines by !!    Mikael Leetmaa <leetmaa@kth.se>, 2014-01-05. changes have !!    been made to incorporate it into the GPF (General Purpose Fortran) !!    framework. !! !!    If you found this useful, please let Mikael Leetmaa know. !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_sha256 !!    use M_hashkeys, only : sha256, dirty_sha256 !!    implicit none !!    character(len=:),allocatable :: str !!    character(len=64)            :: ref !! !!    ! Test the sha256 function with a set of reference strings. !! !!    str=\"\" !!    ref=\"E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 1') !! !!    str=\"abc\" !!    ref=\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 2') !! !!    str=\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" !!    ref=\"248D6A61D20638B8E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 3') !! !!    str=\"abcdefghbcdefghicdefghijdefghijkefghijklfghi& !!         &jklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\" !!    ref=\"CF5B16A778AF8380036CE59E7B0492370B249B11E8F07A51AFAC45037AFEE9D1\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 4') !! !!    str=repeat(\"a\",1000000) !!    ref=\"CDC76E5C9914FB9281A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 5') !! !!    str=\"message digest\" !!    ref=\"F7846F55CF23E14EEBEAB5B4E1550CAD5B509E3348FBC4EFA3A1413D393CB650\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 6') !! !!    str=\"secure hash algorithm\" !!    ref=\"F30CEB2BB2829E79E4CA9753D35A8ECC00262D164CC077080295381CBD643F0D\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 7') !! !!    str=\"SHA256 is considered to be safe\" !!    ref=\"6819D915C73F4D1E77E4E1B52D1FA0F9CF9BEAEAD3939F15874BD988E2A23630\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 8') !! !!    str=\"For this sample, this 63-byte string will be used as input data\" !!    ref=\"F08A78CBBAEE082B052AE0708F32FA1E50C5C421AA772BA5DBB406A2EA6BE342\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 9') !! !!    str=\"This is exactly 64 bytes long, not counting the terminating byte\" !!    ref=\"AB64EFF7E88E2E46165E29F2BCE41826BD4C7B3552F6B382A9E7D3AF47C245F8\" !!    call unit_check('sha256',sha256(str)==ref,'test sha256 10') !! !!    ! Check the quick and dirty implementation as well. !!    ref=\"69E3FACD5F08321F78117BD53476E5321845433356F106E7013E68EC367F3017\" !!    call unit_check('sha256',dirty_sha256(str)==ref,'test dirtysha256 1') !! !!    !!str=repeat(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno\",16777216) !!    !!ref=\"50E72A0E26442FE2552DC3938AC58658228C0CBFB1D2CA872AE435266FCD055E\" !!    !!call unit_check('sha256',sha256(str)==ref,'test sha256 11 -- long test') !! !!    contains !!    subroutine unit_check(name,test,message) !!    character(len=*),intent(in) :: name !!    logical,intent(in)          :: test !!    character(len=*),intent(in) :: message !!       write(*,'(a)') repeat(\"=\",64) !!       write(*,'(a)') sha256(str) !!       write(*,'(a)') ref !!       if(test)then !!          write(*,*)trim(name),\" PASSED: \",trim(message) !!       else !!          write(*,*)trim(name),\" FAILED: \",trim(message) !!       endif !!    end subroutine unit_check !!    ! !!    end program demo_sha256 !! !!##UNIT TEST !! !!   When porting to a new programming environment use the !!   built-in unit test ... !! !!    program test_sha256 !!    use M_hashkeys, only : test_suite_sha256 !!       call test_suite_sha256() !!    end program test_sha256 function sha256 ( str ) implicit none ! ident_1=\"@(#)M_hashkeys::sha256(3f): SHA-256 interface function\" ! Define the interface. character ( len = 64 ) :: sha256 ! The SHA-256 digest as a string of length 64. character ( len =* ), intent ( in ) :: str ! (in) The message to digest. ! Call the work horse with proper bit swapping. sha256 = sha256b ( str , 1 ) end function sha256 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    dirtys_sha256(3f) - [M_hashkeys] generate a SHA-256 hashing !!##SYNOPSIS !! !!   function dirtys_sha256(str) !! !!    character(len=64)            :: dirtys_sha256 !!    character(len=*), intent(in) :: str !! !! !!##DESCRIPTION !! !!    A Fortran module for SHA-256 hashing. !! !!    The quick and dirty routine (dirtys_sha256(3f)) operates on whatever !!    bits that come in, without swapping to big-endian words, and does !!    therefore not pass any of the standard tests - but works at roughly !!    twice the speed. Use this if you want a good hash function but don't !!    care about following the SHA-256 standard specifications. !! !!    Note that this code will not produce the same results on big-endian !!    machines and the module was only tested on a little-endian Ubuntu !!    LTS 12.04 system using gfortran 4.6.3 and CygWin using Gortran 7.3.0. !! !!##OPTIONS !!    str      The message to digest. !! !!##RETURNS !!    dirtys_sha256   The SHA-256 digest as a string of length 64. !! !!##AUTHOR !! !!    This routine is heavily based on the SHA-256 routines by Mikael Leetmaa !!    <leetmaa@kth.se>, 2014-01-05. changes have been made to incorporate !!    it into the GPF (General Purpose Fortran) framework. !! !!    If you found this useful, please let Mikael Leetmaa know. !! !!##EXAMPLES !! !!    Using slurp(3f) and switch(3f) from the GPF (General Purpose Fortran) !!    collection to read in a file and convert it into a string, generate !!    digest values for a list of files. Note that this example reads the !!    entire input file into memory twice, and so requires very large !!    amounts of memory if very large files are processed. !! !!     program demo_dirty_sha256 !!     use,intrinsic :: iso_fortran_env, only : ERROR_UNIT !!     use M_hashkeys,                   only : sha256, dirty_sha256 !!     use M_io,                         only : slurp !!     use M_strings,                    only : switch !!     implicit none !!     character(len=1),allocatable :: text(:) ! array to hold file in memory !!     character(len=:),allocatable :: string !!     integer                      :: i !!     character(len=4096)          :: filename !!        do i=1,command_argument_count()  ! step through filenames on command line !!           call get_command_argument(i, filename) !!           call slurp(filename,text) ! allocate character array and copy file into it !!           if(.not.allocated(text))then !!              write(ERROR_UNIT,*)'*rever* ERROR: failed to load file '//trim(filename) !!           else !!              string=switch(text) ! switch array to a single character variable !!              deallocate(text)    ! release memory !!              write(*,*)dirty_sha256(string),len(string),trim(filename) ! write digest value !!           endif !!        enddo !!     end program demo_dirty_sha256 !! !!   Sample output: !! !!     FA9D11011034F1081A367D4F2F1EB909AC0849FF090A9320B6824156C5628DFD        2011 dynamic_dummy_arrays.f90 !!     FE48473BC7B9C13067EC2C108CB8A650A186605D5F905736D9CB9DE76E9A1A21        5444 fspiro.f90 !!     306CDB5BB2A8C30C711FA5D35A6A12F4FDB4F003ED77438E922B56BBA1024F49       27108 pprint.f90 function dirty_sha256 ( str ) implicit none ! ident_2=\"@(#)M_hashkeys::dirty_sha256(3f): Quick and dirty SHA-256 interface function (no bit-swapping).\" ! Define the interface. character ( len = 64 ) :: dirty_sha256 ! The SHA-256 digest as a string of length 64. character ( len =* ), intent ( in ) :: str ! The message to digest. ! Call the work horse - no bit swapping. dirty_sha256 = sha256b ( str , 0 ) end function dirty_sha256 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function sha256b ( str , swap ) !  Calculate the SHA-256 hash of the incoming string. implicit none ! ----------------------------------- ! Define the interface. character ( len = 64 ) :: sha256b ! return the SHA-256 digest as a string of length 64. character ( len =* ), intent ( in ) :: str ! The message to take digest. integer , intent ( in ) :: swap ! Flag to indicate if swapping to big-endian input (swap=1) should be used. ! swap=1 is needed for the routine to pass the standard tests, ! but decreases speed with a factor 2. ! ----------------------------------- ! Helper variables. integer ( kind = c_int64_t ) :: length integer ( kind = c_int32_t ) :: temp1 integer ( kind = c_int32_t ) :: temp2 integer ( kind = c_int32_t ) :: i integer :: break integer :: pos0 ! Parameters for the cruncher. integer ( kind = c_int32_t ), parameter :: h0_ref ( 8 ) = [& & int ( z '6a09e667' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z 'bb67ae85' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '3c6ef372' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z 'a54ff53a' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '510e527f' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '9b05688c' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '1f83d9ab' , kind = c_int32_t ), & & int ( z '5be0cd19' , kind = c_int32_t )] integer ( kind = c_int32_t ), parameter :: k0_ref ( 64 ) = [ & & int ( z '428a2f98' , kind = c_int32_t ), int ( z '71374491' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z 'b5c0fbcf' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'e9b5dba5' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '3956c25b' , kind = c_int32_t ), int ( z '59f111f1' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '923f82a4' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'ab1c5ed5' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'd807aa98' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '12835b01' , kind = c_int32_t ), int ( z '243185be' , kind = c_int32_t ), int ( z '550c7dc3' , kind = c_int32_t ), & & int ( z '72be5d74' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '80deb1fe' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z '9bdc06a7' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'c19bf174' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'e49b69c1' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'efbe4786' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '0fc19dc6' , kind = c_int32_t ), int ( z '240ca1cc' , kind = c_int32_t ), int ( z '2de92c6f' , kind = c_int32_t ), & & int ( z '4a7484aa' , kind = c_int32_t ), int ( z '5cb0a9dc' , kind = c_int32_t ), int ( z '76f988da' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '983e5152' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'a831c66d' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'b00327c8' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'bf597fc7' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'c6e00bf3' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'd5a79147' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '06ca6351' , kind = c_int32_t ), int ( z '14292967' , kind = c_int32_t ), int ( z '27b70a85' , kind = c_int32_t ), & & int ( z '2e1b2138' , kind = c_int32_t ), int ( z '4d2c6dfc' , kind = c_int32_t ), int ( z '53380d13' , kind = c_int32_t ), & & int ( z '650a7354' , kind = c_int32_t ), int ( z '766a0abb' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '81c2c92e' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z '92722c85' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'a2bfe8a1' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'a81a664b' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'c24b8b70' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'c76c51a3' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'd192e819' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'd6990624' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'f40e3585' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & int ( z '106aa070' , kind = c_int32_t ), & & int ( z '19a4c116' , kind = c_int32_t ), int ( z '1e376c08' , kind = c_int32_t ), int ( z '2748774c' , kind = c_int32_t ), & & int ( z '34b0bcb5' , kind = c_int32_t ), int ( z '391c0cb3' , kind = c_int32_t ), int ( z '4ed8aa4a' , kind = c_int32_t ), & & int ( z '5b9cca4f' , kind = c_int32_t ), int ( z '682e6ff3' , kind = c_int32_t ), int ( z '748f82ee' , kind = c_int32_t ), & & int ( z '78a5636f' , kind = c_int32_t ), & & ibset ( int ( ibclr ( int ( z '84c87814' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z '8cc70208' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z '90befffa' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'a4506ceb' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'bef9a3f7' , kind = int64 ), 31 ), kind = c_int32_t ), 31 ), & & ibset ( int ( ibclr ( int ( z 'c67178f2' , kind = int64 ), 31 ), kind = c_int32_t ), 31 )] ! Work areas. integer ( kind = c_int32_t ) :: h0 ( 8 ) integer ( kind = c_int32_t ) :: k0 ( 64 ) integer ( kind = c_int32_t ) :: a0 ( 8 ) integer ( kind = c_int32_t ) :: w0 ( 64 ) h0 = h0_ref k0 = k0_ref ! ----------------------------------- ! Function body implementation. break = 0 pos0 = 1 length = len ( trim ( str )) do while ( break . ne . 1 ) ! Get the next 16 32bit words to consume. call consume_chunk ( str , length , w0 ( 1 : 16 ), pos0 , break , swap ) ! Extend the first 16 words to fill the work schedule array. do i = 17 , 64 w0 ( i ) = ms1 ( w0 ( i - 2 )) + w0 ( i - 16 ) + ms0 ( w0 ( i - 15 )) + w0 ( i - 7 ) enddo ! Initialize the workin variables with the current version of the hash. a0 = h0 ! Run the compression loop. do i = 1 , 64 temp1 = a0 ( 8 ) + cs1 ( a0 ( 5 )) + ch ( a0 ( 5 ), a0 ( 6 ), a0 ( 7 )) + k0 ( i ) + w0 ( i ) temp2 = cs0 ( a0 ( 1 )) + maj ( a0 ( 1 ), a0 ( 2 ), a0 ( 3 )) a0 ( 8 ) = a0 ( 7 ) a0 ( 7 ) = a0 ( 6 ) a0 ( 6 ) = a0 ( 5 ) a0 ( 5 ) = a0 ( 4 ) + temp1 a0 ( 4 ) = a0 ( 3 ) a0 ( 3 ) = a0 ( 2 ) a0 ( 2 ) = a0 ( 1 ) a0 ( 1 ) = temp1 + temp2 enddo ! Update the state. h0 = h0 + a0 enddo ! Write the result to the output variable. write ( sha256b , '(8z8.8)' ) h0 ( 1 ), h0 ( 2 ), h0 ( 3 ), h0 ( 4 ), h0 ( 5 ), h0 ( 6 ), h0 ( 7 ), h0 ( 8 ) end function sha256b !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> Swap the byte order on a 32bit integer. !! @param inp : (in) The integer to byte swap. !! @return    : The byte swapped integer. function swap32 ( inp ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: swap32 integer ( kind = c_int32_t ), intent ( in ) :: inp ! ----------------------------------- swap32 = 0 !  ifort (IFORT) 2021.3.0 20210609 bug call mvbits ( inp , 24 , 8 , swap32 , 0 ) call mvbits ( inp , 16 , 8 , swap32 , 8 ) call mvbits ( inp , 8 , 8 , swap32 , 16 ) call mvbits ( inp , 0 , 8 , swap32 , 24 ) end function swap32 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> Swap the byte order on a 64 bit integer. !! @param inp : (in) The integer to byte swap. !! @return    : The byte swapped integer. function swap64 ( inp ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int64_t ) :: swap64 integer ( kind = c_int64_t ), intent ( in ) :: inp ! ----------------------------------- swap64 = 0 !  ifort (IFORT) 2021.3.0 20210609 bug call mvbits ( inp , 56 , 8 , swap64 , 0 ) call mvbits ( inp , 48 , 8 , swap64 , 8 ) call mvbits ( inp , 40 , 8 , swap64 , 16 ) call mvbits ( inp , 32 , 8 , swap64 , 24 ) call mvbits ( inp , 24 , 8 , swap64 , 32 ) call mvbits ( inp , 16 , 8 , swap64 , 40 ) call mvbits ( inp , 8 , 8 , swap64 , 48 ) call mvbits ( inp , 0 , 8 , swap64 , 56 ) end function swap64 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> Swap the byte order on a 64bit integer as if !! each half was a 32bit integer to swap. !! @param inp : (in) The integer to byte swap. !! @return    : The byte swapped integer. function swap64a ( inp ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int64_t ) :: swap64a integer ( kind = c_int64_t ), intent ( in ) :: inp ! ----------------------------------- swap64a = 0 !  ifort (IFORT) 2021.3.0 20210609 bug call mvbits ( inp , 0 , 8 , swap64a , 32 ) call mvbits ( inp , 8 , 8 , swap64a , 40 ) call mvbits ( inp , 16 , 8 , swap64a , 48 ) call mvbits ( inp , 24 , 8 , swap64a , 56 ) call mvbits ( inp , 32 , 8 , swap64a , 0 ) call mvbits ( inp , 40 , 8 , swap64a , 8 ) call mvbits ( inp , 48 , 8 , swap64a , 16 ) call mvbits ( inp , 56 , 8 , swap64a , 24 ) end function swap64a !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> The 'ch' function in SHA-2. !! @param a : (in) The a input integer. !! @param b : (in) The b input integer. !! @param c : (in) The c input integer. !! @return  : ch(a,b,c), see the code. function ch ( a , b , c ) ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: ch integer ( kind = c_int32_t ), intent ( in ) :: a integer ( kind = c_int32_t ), intent ( in ) :: b integer ( kind = c_int32_t ), intent ( in ) :: c ! ----------------------------------- ch = ieor ( iand ( a , b ), ( iand ( not ( a ), c ))) end function ch !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function maj ( a , b , c ) !> The 'maj' function in SHA-2. !! @param a : (in) The a input integer. !! @param b : (in) The b input integer. !! @param c : (in) The c input integer. !! @return  : maj(a,b,c), see the code. ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: maj integer ( kind = c_int32_t ), intent ( in ) :: a integer ( kind = c_int32_t ), intent ( in ) :: b integer ( kind = c_int32_t ), intent ( in ) :: c ! ----------------------------------- maj = ieor ( iand ( a , b ), ieor ( iand ( a , c ), iand ( b , c ))) end function maj !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> The '\\Sigma_0' function in SHA-2. !! @param a : (in) The a input integer. !! @return  : cs0(a), see the code. function cs0 ( a ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: cs0 integer ( kind = c_int32_t ), intent ( in ) :: a ! ----------------------------------- cs0 = ieor ( ishftc ( a , - 2 ), ieor ( ishftc ( a , - 13 ), ishftc ( a , - 22 ))) end function cs0 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> The '\\Sigma_1' function in SHA-2. !! @param a : (in) The a input integer. !! @return  : cs1(a), see the code. function cs1 ( a ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: cs1 integer ( kind = c_int32_t ), intent ( in ) :: a ! ----------------------------------- cs1 = ieor ( ishftc ( a , - 6 ), ieor ( ishftc ( a , - 11 ), ishftc ( a , - 25 ))) end function cs1 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> The '\\sigma_0' function in SHA-2. !! @param a : (in) The a input integer. !! @return  : ms0(a), see the code. function ms0 ( a ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: ms0 integer ( kind = c_int32_t ), intent ( in ) :: a ! ----------------------------------- ms0 = ieor ( ishftc ( a , - 7 ), ieor ( ishftc ( a , - 18 ), ishft ( a , - 3 ))) end function ms0 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> The '\\sigma_1' function in SHA-2. !! @param a : (in) The a input integer. !! @return  : ms1(a), see the code. function ms1 ( a ) implicit none ! ----------------------------------- ! Define the interface. integer ( kind = c_int32_t ) :: ms1 integer ( kind = c_int32_t ), intent ( in ) :: a ! ----------------------------------- ms1 = ieor ( ishftc ( a , - 17 ), ieor ( ishftc ( a , - 19 ), ishft ( a , - 10 ))) end function ms1 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> Copy 16 32bit words of data from str(pos0) to inp(1:16). The !! data is padded as required by the SHA-256 algorithm. !! @param str    : (in) The message to take a chunk from. !! @param length : (in) The length of the message in 8bit words. !! @param inp    : (inout) The work area to copy the data to. !! @param pos0   : (inout) Variable to store the start of the next chunk. !! @param break  : (inout) Indicates the position in the work flow. !!                 break=0 on entry -> continue to consume a chunk, pad if needed. !!                 break=2 on entry -> continue to consume, padding was already done. !!                 break=1 one exit -> the last chunk was consumed. !! @param swap   : (in) Flag to indicate if swapping to big-endian !!                 input (swap=1) should be used. swap=1 is needed !!                 for the routine to pass the standard tests, but !!                 decreases speed with a factor 2. subroutine consume_chunk ( str , length , inp , pos0 , break , swap ) implicit none ! ----------------------------------- ! Define the interface. character ( len =* ), intent ( in ) :: str integer ( kind = c_int64_t ), intent ( in ) :: length integer ( kind = c_int32_t ), intent ( inout ) :: inp ( * ) integer , intent ( inout ) :: pos0 integer , intent ( inout ) :: break integer , intent ( in ) :: swap ! ----------------------------------- ! Internal variables. character ( len = 4 ) :: last_word integer ( kind = c_int64_t ) :: rest integer ( kind = c_int32_t ) :: to_pad integer ( kind = c_int32_t ) :: leftover integer ( kind = c_int32_t ) :: space_left ! KLUDGE SYNTAX NOT STANDARD BUT WORKS EVERYWHERE integer ( kind = c_int32_t ), parameter :: zero = int ( b '00000000000000000000000000000000' , kind = c_int32_t ) integer ( kind = c_int8_t ), parameter :: ipad0 = int ( b '00000000' , kind = c_int8_t ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !NO_ON_SOME-A!integer(kind=c_int8_t),parameter  :: ipad1=int(b'10000000',kind=c_int8_t) !WORKS-B!integer(kind=int64),save :: ipad1__              =int(b'10000000',kind=int64)  !        -128        128 !WORKS-B!integer(kind=c_int8_t),save :: ipad1             ;equivalence(ipad1,ipad1__) integer ( kind = c_int8_t ), parameter :: ipad1 = ibset ( int ( ibclr ( int ( b '10000000' , kind = int64 ), 7 ), kind = c_int8_t ), 7 ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> integer ( kind = c_int8_t ) :: i ! Calculate the rest. rest = length - pos0 + 1 ! If we are far from the end. if ( rest . ge . 64 ) then ! Copy the data over. inp ( 1 : 16 ) = transfer ( str ( pos0 : pos0 + 64 - 1 ), inp ( 1 : 16 )) ! Big-endian. if ( swap . eq . 1 ) then do i = 1 , 16 inp ( i ) = swap32 ( inp ( i )) enddo endif pos0 = pos0 + 64 ! Increment the starting position for the next roundx. else space_left = 16 ! Space left in the input chunk. leftover = rest / 4 ! number of leftover full 32bit words. ! Copy any leftovers. if ( leftover . gt . 0 ) then inp ( 1 : leftover ) = transfer ( str ( pos0 : pos0 + leftover * 4 - 1 ), inp ( 1 : 16 )) ! Big-endian. if ( swap . eq . 1 ) then do i = 1 , leftover inp ( i ) = swap32 ( inp ( i )) enddo endif ! Increment the starting position. pos0 = pos0 + leftover * 4 rest = length - pos0 + 1 space_left = space_left - leftover endif if ( space_left . gt . 0 ) then if ( break . ne . 2 ) then ! Add any remaining incomplete 32bit word. if ( rest . gt . 0 ) then last_word ( 1 : rest ) = str ( pos0 : pos0 + rest - 1 ) pos0 = pos0 + rest ! Increment the pos0. endif last_word ( rest + 1 : rest + 1 ) = transfer ( ipad1 , last_word ( 1 : 1 )) ! Add the '10000000' padding. to_pad = 4 - rest - 1 ! Add zeros for a full 32bit word. do i = 1 , to_pad last_word ( rest + 1 + i : rest + 1 + i ) = transfer ( ipad0 , last_word ( 1 : 1 )) enddo inp ( 17 - space_left ) = transfer ( last_word ( 1 : 4 ), inp ( 1 )) ! Copy the last full (padded) word over. if ( swap . eq . 1 ) then inp ( 17 - space_left ) = swap32 ( inp ( 17 - space_left )) endif space_left = space_left - 1 ! Decrement the space left. break = 2 ! Set the flag to indicate that we have padded. endif if ( space_left . eq . 1 ) then ! If not enough space to finish, add zeros. inp ( 16 ) = zero space_left = 0 endif rest = 0 endif if (( rest . eq . 0 ) . and . ( space_left . ge . 2 )) then ! Continue with the last part if there is enough space left. do while ( space_left . gt . 2 ) ! Add zeros until 64 bits left. inp ( 17 - space_left ) = zero space_left = space_left - 1 enddo inp ( 15 : 16 ) = transfer ( swap64a ( length * 8 ), inp ( 15 : 16 )) ! Add the two last 32bit words. break = 1 ! Set break flag indicating we are done with the whole message. endif endif end subroutine consume_chunk !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== ! TEST SUITE FOR THE bitsy SHA-256 FORTRAN IMPLEMENTATION ! Author: Mikael Leetmaa ! Date:   05 Jan 2014 subroutine test_suite_sha256 () use M_verify , only : unit_check , unit_check_start , unit_check_done use M_verify , only : unit_check_level implicit none integer ( kind = int32 ), parameter :: ipad1 = int ( b '00000000000000000000000000000011' , kind = int32 ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> integer ( kind = int32 ), parameter :: ipad2 = ibset ( int ( ibclr ( int ( b '11111111111111111111111111111111' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad3 = ibset ( int ( ibclr ( int ( b '10010000101001110011001110010011' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad4 = ibset ( int ( ibclr ( int ( b '11001001101001110011001110010011' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad5 = ibset ( int ( ibclr ( int ( b '10000001101001010011000110100001' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad6 = ibset ( int ( ibclr ( int ( b '11000000000000000000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: shftc4_r2 = ibset ( int ( ibclr ( int ( b '11110010011010011100110011100100' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: empty_str_bin_flip & & = ibset ( int ( ibclr ( int ( b '10000000000000000000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: big_endian_464 & & = ibset ( int ( ibclr ( int ( b '11010000000000010000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> integer ( kind = int32 ), parameter :: shftc4_l12 = int ( b '01110011001110010011110010011010' , kind = int32 ) integer ( kind = int32 ), parameter :: shft5_r8 = int ( b '00000000100000011010010100110001' , kind = int32 ) integer ( kind = int32 ), parameter :: shft5_l11 = int ( b '00101001100011010000100000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin = int ( b '00000001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: a_bin = int ( b '00000000000000000000000101100001' , kind = int32 ) integer ( kind = int32 ), parameter :: empty_str_bin = int ( b '00000000000000000000000000000001' , kind = int32 ) integer ( kind = int32 ), parameter :: empty_bin = int ( b '00000000000000000000000000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_flip = int ( b '01100001011000100110001110000000' , kind = int32 ) integer ( kind = int32 ), parameter :: a_bin_flip = int ( b '01100001100000000000000000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abca_bin = int ( b '01100001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: bcab_bin = int ( b '01100010011000010110001101100010' , kind = int32 ) integer ( kind = int32 ), parameter :: cabc_bin = int ( b '01100011011000100110000101100011' , kind = int32 ) integer ( kind = int32 ), parameter :: ca_one_zero = int ( b '00000000000000010110000101100011' , kind = int32 ) integer ( kind = int32 ), parameter :: little_endian_464 = int ( b '00000000000000000000000111010000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_ref = int ( b '00000001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_swap = int ( b '01100001011000100110001100000001' , kind = int32 ) integer ( kind = int32 ), parameter :: abca_bin_flip = int ( b '01100001011000100110001101100001' , kind = int32 ) integer ( kind = int32 ), parameter :: bcab_bin_flip = int ( b '01100010011000110110000101100010' , kind = int32 ) integer ( kind = int32 ), parameter :: cabc_bin_flip = int ( b '01100011011000010110001001100011' , kind = int32 ) integer ( kind = int32 ), parameter :: ca_one_zero_flip = int ( b '01100011011000011000000000000000' , kind = int32 ) call test_swap32 call test_ishftc call test_ishft call pad_message1 call pad_message2 call test_ch call test_maj call test_cs0 call test_cs1 call test_ms0 call test_ms1 call test_sha256_1 call test_sha256_5 call test_sha256_6 call test_sha256_11 contains ! Test the swap function. subroutine test_swap32 call unit_check_start ( 'swap32' ) call unit_check ( 'swap32' , swap32 ( abc_bin ) == abc_bin_swap , 'test swap32 function' ) call unit_check ( 'swap32' , abc_bin == abc_bin_ref , 'test swap value' ) call unit_check_done ( 'swap32' ) end subroutine test_swap32 subroutine test_ishftc ! Make sure the intrinsic ishftc function does what we think. integer ( kind = int32 ) :: a call unit_check_start ( 'ishftc' ) a = ishftc ( ipad4 , - 2 ) call unit_check ( 'ishftc' , a == shftc4_r2 , 'verify ishftc A' ) a = ishftc ( ipad4 , 12 ) call unit_check ( 'ishftc' , a == shftc4_l12 , 'verify ishftc B' ) call unit_check_done ( 'ishftc' ) end subroutine test_ishftc ! Make sure the intrinsic ishft function does what we think. subroutine test_ishft integer ( kind = int32 ) :: a call unit_check_start ( 'ishft' ) a = ishft ( ipad5 , - 8 ) call unit_check ( 'ishft' , a == shft5_r8 , 'verify ishft A' ) a = ishft ( ipad5 , 11 ) call unit_check ( 'ishft' , a == shft5_l11 , 'verify ishft B' ) call unit_check_done ( 'ishft' ) end subroutine test_ishft ! Test the message padding. subroutine pad_message1 character ( len = 1000 ) :: str integer ( kind = int32 ) :: inp ( 16 ) integer ( kind = 8 ) :: length integer :: pos0 , break integer :: swap = 1 call unit_check_start ( 'pad_message1' ) ! Set the message to \"\". str = \"\" pos0 = 1 break = 0 length = 0 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == empty_str_bin_flip , 'message padding A' ) ! Set the message to \"abc\". str = \"abc\" pos0 = 1 break = 0 length = 3 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == abc_bin_flip , 'message padding B' ) ! Set the message to \"a\". str = \"a\" pos0 = 1 break = 0 length = 1 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == a_bin_flip , 'message padding C' ) call unit_check_done ( 'pad_message1' ) end subroutine pad_message1 ! Test the message padding. subroutine pad_message2 character ( len = 1024 ) :: str integer ( kind = int32 ) :: inp ( 16 ) integer ( kind = 8 ) :: length integer :: pos0 , break integer :: swap = 1 ! Set the message. str = \"abcabcabcabcabcaabcabcabcabcabcaabcabcabcabcabcaabcabcabca\" pos0 = 1 break = 0 length = 58 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the whole message. call unit_check_start ( 'pad_message2' ) call unit_check ( 'pad_message2' , inp ( 1 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 2 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 3 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 4 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 5 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 6 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 7 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 8 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 9 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 10 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 11 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 12 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 13 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 14 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 15 ) == ca_one_zero_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 16 ) == empty_bin , 'message padding 2' ) call consume_chunk ( str , length , inp , pos0 , break , swap ) call unit_check ( 'pad_message2' , inp ( 1 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 2 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 3 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 4 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 5 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 6 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 7 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 8 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 9 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 10 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 11 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 12 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 13 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 14 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 15 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 16 ) == little_endian_464 , 'message padding 2' ) call unit_check_done ( 'pad_message2' ) end subroutine pad_message2 ! Test the ch function. subroutine test_ch integer ( kind = int32 ) :: e , f , g integer ( kind = int32 ) :: aa , bb e = ipad1 f = ipad2 g = ipad3 aa = iand ( not ( e ), g ) bb = iand ( e , f ) call unit_check_start ( 'test_ch' ) call unit_check ( 'test_ch' , ieor ( aa , bb ) == maj ( e , f , g ), 'test the ch function' ) call unit_check_done ( 'test_ch' ) end subroutine test_ch ! Test the maj function. subroutine test_maj integer ( kind = int32 ) :: a , b , c integer ( kind = int32 ) :: aa , bb , cc call unit_check_start ( 'test_maj' ) a = ipad1 b = ipad2 c = ipad3 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad2 b = ipad3 c = ipad4 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad3 b = ipad4 c = ipad5 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad4 b = ipad5 c = ipad6 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) call unit_check_done ( 'test_maj' ) end subroutine test_maj ! Test the major sigma-0 function. subroutine test_cs0 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_cs0' ) a = ishftc ( ipad1 , - 2 ) b = ishftc ( ipad1 , - 13 ) c = ishftc ( ipad1 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad1 ), 'test the major sigma-9 function' ) a = ishftc ( ipad2 , - 2 ) b = ishftc ( ipad2 , - 13 ) c = ishftc ( ipad2 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad2 ), 'test the major sigma-9 function' ) a = ishftc ( ipad3 , - 2 ) b = ishftc ( ipad3 , - 13 ) c = ishftc ( ipad3 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad3 ), 'test the major sigma-9 function' ) a = ishftc ( ipad4 , - 2 ) b = ishftc ( ipad4 , - 13 ) c = ishftc ( ipad4 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad4 ), 'test the major sigma-9 function' ) a = ishftc ( ipad5 , - 2 ) b = ishftc ( ipad5 , - 13 ) c = ishftc ( ipad5 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad5 ), 'test the major sigma-9 function' ) a = ishftc ( ipad6 , - 2 ) b = ishftc ( ipad6 , - 13 ) c = ishftc ( ipad6 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad6 ), 'test the major sigma-9 function' ) call unit_check_done ( 'test_cs0' ) end subroutine test_cs0 ! Test the major sigma-1 function. subroutine test_cs1 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_cs1' ) a = ishftc ( ipad1 , - 6 ) b = ishftc ( ipad1 , - 11 ) c = ishftc ( ipad1 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad1 ), 'test the major sigma-9 function' ) a = ishftc ( ipad2 , - 6 ) b = ishftc ( ipad2 , - 11 ) c = ishftc ( ipad2 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad2 ), 'test the major sigma-9 function' ) a = ishftc ( ipad3 , - 6 ) b = ishftc ( ipad3 , - 11 ) c = ishftc ( ipad3 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad3 ), 'test the major sigma-9 function' ) a = ishftc ( ipad4 , - 6 ) b = ishftc ( ipad4 , - 11 ) c = ishftc ( ipad4 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad4 ), 'test the major sigma-9 function' ) a = ishftc ( ipad5 , - 6 ) b = ishftc ( ipad5 , - 11 ) c = ishftc ( ipad5 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad5 ), 'test the major sigma-9 function' ) a = ishftc ( ipad6 , - 6 ) b = ishftc ( ipad6 , - 11 ) c = ishftc ( ipad6 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad6 ), 'test the major sigma-9 function' ) call unit_check_done ( 'test_cs1' ) end subroutine test_cs1 ! Test the minor sigma-0 function. subroutine test_ms0 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_ms0' ) a = ishftc ( ipad1 , - 7 ) b = ishftc ( ipad1 , - 18 ) c = ishft ( ipad1 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad1 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad2 , - 7 ) b = ishftc ( ipad2 , - 18 ) c = ishft ( ipad2 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad2 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad3 , - 7 ) b = ishftc ( ipad3 , - 18 ) c = ishft ( ipad3 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad3 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad4 , - 7 ) b = ishftc ( ipad4 , - 18 ) c = ishft ( ipad4 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad4 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad5 , - 7 ) b = ishftc ( ipad5 , - 18 ) c = ishft ( ipad5 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad5 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad6 , - 7 ) b = ishftc ( ipad6 , - 18 ) c = ishft ( ipad6 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad6 ), 'test the minor sigma-0 function' ) call unit_check_done ( 'test_ms0' ) end subroutine test_ms0 ! Test the minor sigma-1 function. subroutine test_ms1 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_ms1' ) a = ishftc ( ipad1 , - 17 ) b = ishftc ( ipad1 , - 19 ) c = ishft ( ipad1 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad1 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad2 , - 17 ) b = ishftc ( ipad2 , - 19 ) c = ishft ( ipad2 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad2 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad3 , - 17 ) b = ishftc ( ipad3 , - 19 ) c = ishft ( ipad3 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad3 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad4 , - 17 ) b = ishftc ( ipad4 , - 19 ) c = ishft ( ipad4 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad4 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad5 , - 17 ) b = ishftc ( ipad5 , - 19 ) c = ishft ( ipad5 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad5 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad6 , - 17 ) b = ishftc ( ipad6 , - 19 ) c = ishft ( ipad6 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad6 ), 'test the minor sigma-1 function' ) call unit_check_done ( 'test_ms1' ) end subroutine test_ms1 ! Test the sha256 function with a set of reference strings. subroutine test_sha256_1 character ( len = 1000000 ) :: str call unit_check_start ( 'test_sha256_1' ) str = \"\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\" , 'sha256 1' ) str = \"abc\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\" , 'sha256 2' ) str = \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"248D6A61D20638B8E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" , 'sha256 3' ) str = \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"CF5B16A778AF8380036CE59E7B0492370B249B11E8F07A51AFAC45037AFEE9D1\" , 'sha256 4' ) call unit_check_done ( 'test_sha256_1' ) end subroutine test_sha256_1 subroutine test_sha256_5 character ( len = 1000000 ) :: str character ( len = 64 ) :: ref integer :: i call unit_check_start ( 'test_sha256_5' ) do i = 1 , 1000000 str ( i : i ) = \"a\" enddo call unit_check ( 'test_sha256_5' , sha256 ( str ) == \"CDC76E5C9914FB9281A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\" , 'sha256 5' ) ! Check the quick and dirty implementation as well. ref = \"69E3FACD5F08321F78117BD53476E5321845433356F106E7013E68EC367F3017\" call unit_check ( 'test_sha256_5' , dirty_sha256 ( str ) == ref , 'test sha256 6' ) call unit_check_done ( 'test_sha256_5' ) end subroutine test_sha256_5 subroutine test_sha256_6 character ( len = 1000000 ) :: str call unit_check_start ( 'test_sha256_6' ) str = \"message digest\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F7846F55CF23E14EEBEAB5B4E1550CAD5B509E3348FBC4EFA3A1413D393CB650\" , 'sha256 6' ) str = \"secure hash algorithm\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F30CEB2BB2829E79E4CA9753D35A8ECC00262D164CC077080295381CBD643F0D\" , 'sha256 7 ' ) str = \"SHA256 is considered to be safe\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"6819D915C73F4D1E77E4E1B52D1FA0F9CF9BEAEAD3939F15874BD988E2A23630\" , 'sha256 8 ' ) str = \"For this sample, this 63-byte string will be used as input data\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F08A78CBBAEE082B052AE0708F32FA1E50C5C421AA772BA5DBB406A2EA6BE342\" , 'sha256 9 ' ) str = \"This is exactly 64 bytes long, not counting the terminating byte\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"AB64EFF7E88E2E46165E29F2BCE41826BD4C7B3552F6B382A9E7D3AF47C245F8\" , 'sha256 10 ' ) call unit_check_done ( 'test_sha256_6' ) end subroutine test_sha256_6 subroutine test_sha256_11 !integer,parameter     :: big=16777216  ! too big for ifort !integer,parameter     :: big=167777  ! too big for ifort integer , parameter :: big = 16777 character ( len = big * 64 ) :: str integer :: i call unit_check_start ( 'test_sha256_11' ) !write(*,*)'A long test' do i = 1 , big str ( 1 + ( i - 1 ) * 64 : i * 64 ) = \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno\" enddo !call unit_check('test_sha256_11',sha256(str)==\"50E72A0E26442FE2552DC3938AC58658228C0CBFB1D2CA872AE435266FCD055E\",'sha256 11') !call unit_check('test_sha256_11',sha256(str)==\"6BC568C54C0BB123FBCA27DAD40067345DD9FBE61E1376FE3C27902943FCF6A5\",& !& 'sha256 11 GOT',sha256(str),'expected 6BC568C54C0BB123FBCA27DAD40067345DD9FBE61E1376FE3C27902943FCF6A5') call unit_check ( 'test_sha256_11' , sha256 ( str ) == \"711CC2AB7E0A98D1EDBDA435A7B219E8AAA12661F347339A14041208751373C6\" , & & 'sha256 11 GOT' , sha256 ( str ), 'expected 711CC2AB7E0A98D1EDBDA435A7B219E8AAA12661F347339A14041208751373C6' ) call unit_check_done ( 'test_sha256_11' ) end subroutine test_sha256_11 end subroutine test_suite_sha256 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    luhn_checksum(3f) - [M_hashkeys] Luhn checksum algorithm applied to a string of numeric values !! !!##DESCRIPTION !! !!    The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or !!    \"mod 10\" algorithm, named after IBM scientist Hans Peter Luhn, is a simple !!    checksum formula used to validate a variety of identification numbers !!    such as credit card numbers, IMEI numbers, National Provider Identifier !!    numbers in the United States, Canadian Social Insurance Numbers, Israel !!    ID Numbers, Greek Social Security Numbers, and survey codes appearing on !!    McDonald's, Taco Bell, and Tractor Supply Co. receipts. It was created by !!    IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, !!    filed on January 6, 1954, and granted on August 23, 1960. !! !!    The algorithm is in the public domain and is in wide use today. It !!    is specified in ISO/IEC 7812-1.[1] It is not intended to be a !!    cryptographically secure hash function; it was designed to protect against !!    accidental errors, not malicious attacks. Most credit cards and many !!    government identification numbers use the algorithm as a simple method of !!    distinguishing valid numbers from mistyped or otherwise incorrect numbers. !! !!    The formula verifies a number against its included check digit, which !!    is usually appended to a partial account number to generate the full !!    account number. This number must pass the following test: !! !!    1. From the rightmost digit, which is the check digit, and moving left, !!       double the value of every second digit. The check digit is not doubled; !!       the first digit doubled is immediately to the left of the check digit. If !!       the result of this doubling operation is greater than 9 (e.g., 8 × 2 = !!       16), then add the digits of the result (e.g., 16: 1 + 6 = 7, 18: 1 + 8 = !!       9) or, alternatively, the same final result can be found by subtracting !!       9 from that result (e.g., 16: 16 − 9 = 7, 18: 18 − 9 = 9). !! !!    2. Take the sum of all the digits. !! !!    3. If the total modulo 10 is equal to 0 (if the total ends in zero) then !!       the number is valid according to the Luhn formula; else it is not valid. !! !!    Assume an example of an account number \"7992739871\" that will have a !!    check digit added, making it of the form 7992739871x: !! !!    Account number !! !!        7  9  9  2  7  3  9  8  7  1  x !! !!    Double every other !! !!        7  18  9  4  7  6  9  16  7  2  x !! !!    Sum digits !! !!        7  9  9  4  7  6  9  7  7  2  x !! !!    The sum of all the digits in the third row is 67+x. !! !!    The check digit (x) is obtained by computing the sum of the non-check !!    digits then computing 9 times that value modulo 10 (in equation form, !!    ((67 × 9) mod 10)). In algorithm form: !! !!     1. Compute the sum of the non-check digits (67). !!     2. Multiply by 9 (603). !!     3. The units digit (3) is the check digit. Thus, x=3. !! !!    (Alternative method) The check digit (x) is obtained by computing the sum !!    of the other digits (third row) then subtracting the units digit from 10 !!    (67 => Units digit 7; 10 − 7 = check digit 3). In algorithm form: !! !!     1. Compute the sum of the non-check digits (67). !!     2. Take the units digit (7). !!     3. Subtract the units digit from 10. !!     4. The result (3) is the check digit. In case the sum of digits ends in !!        0 then 0 is the check digit. !! !!    This makes the full account number read 79927398713. !! !!    Each of the numbers 79927398710, 79927398711, 79927398712, 79927398713, !!    79927398714, 79927398715, 79927398716, 79927398717, 79927398718, !!    79927398719 can be validated as follows. !! !!     1. Double every second digit, from the rightmost: (1×2) = 2, (8×2) = 16, !!        (3×2) = 6, (2×2) = 4, (9×2) = 18 !!     2. Sum all the individual digits (digits in parentheses are the products !!        from Step 1): x (the check digit) + (2) + 7 + (1+6) + 9 + (6) + 7 + !!        (4) + 9 + (1+8) + 7 = x + 67. !!     3. If the sum is a multiple of 10, the account number is possibly !!        valid. Note that 3 is the only valid digit that produces a sum (70) !!        that is a multiple of 10. !!     4. Thus these account numbers are all invalid except possibly 79927398713 !!        which has the correct check digit. !! !!    Alternately, you can use the same checksum creation algorithm, ignoring !!    the checksum already in place as if it had not yet been calculated. Then !!    calculate the checksum and compare this calculated checksum to the !!    original checksum included with the credit card number. If the included !!    checksum matches the calculated checksum, then the number is valid. !! !!##STRENGTHS AND WEAKNESSES !! !!    The Luhn algorithm will detect any single-digit error, as well as almost !!    all transpositions of adjacent digits. It will not, however, detect !!    transposition of the two-digit sequence 09 to 90 (or vice versa). It will !!    detect 7 of the 10 possible twin errors (it will not detect 22 ↔ 55, !!    33 ↔ 66 or 44 ↔ 77). !! !!    Other, more complex check-digit algorithms (such as the Verhoeff algorithm !!    and the Damm algorithm) can detect more transcription errors. The Luhn !!    mod N algorithm is an extension that supports non-numerical strings. !! !!    Because the algorithm operates on the digits in a right-to-left manner !!    and zero digits affect the result only if they cause shift in position, !!    zero-padding the beginning of a string of numbers does not affect the !!    calculation. Therefore, systems that pad to a specific number of digits !!    (by converting 1234 to 0001234 for instance) can perform Luhn validation !!    before or after the padding and achieve the same result. !! !!    Prepending a 0 to odd-length numbers makes it possible to process !!    the number from left to right rather than right to left, doubling the !!    odd-place digits. !! !!    The algorithm appeared in a US Patent[2] for a hand-held, mechanical !!    device for computing the checksum. It was therefore required to be !!    rather simple. The device took the mod 10 sum by mechanical means. The !!    substitution digits, that is, the results of the double and reduce !!    procedure, were not produced mechanically. Rather, the digits were marked !!    in their permuted order on the body of the machine. !!##OPTIONS !! !!      S                 the string of digits to be checked. Spaces and dashes !!                        are ignored. !! !!##RESULT !! !!      LUHN_CHECKSUM     the Luhn checksum of the string; which is the digits in the !!                        input string with the checksum digit appended. !! !!##REFERENCES !!    From Wikipedia, the free encyclopedia !! !!        (https://en.wikipedia.org/wiki/Luhn_algorithm) !!##EXAMPLES !! !!  Sample program !! !!      program demo_luhn_checksum !!      use M_hashkeys, only : luhn_checksum !!      implicit none !!      character(len=:),allocatable :: ccards(:), string !!      integer :: i, j !!      write(*,*)'GOOD VALUES' !!      ccards=[ character(len=20) :: '79927398713', & !!                                  & '49927398716',& !!                                  & '1234567812345670' ] !!      call checkem() !!      write(*,*)'BAD VALUES' !!      ccards=[ character(len=20) :: & !!        & '79927398710', '79927398711', '79927398712', '79927398714',  & !!        & '79927398715', '79927398716', '79927398717', '79927398718',  & !!        & '79927398719',  & !!         '49927398717', '1234567812345678' ] !!      call checkem() !!      contains !!      subroutine checkem !!         ! validate these numbers !!         do i=1,size(ccards) !!            j=len(trim(ccards(i))) !!            string=luhn_checksum(ccards(i)(:j-1)) !!            write(*,'(a,1x,a,1x,l1)')ccards(i),string,ccards(i).eq.string !!         enddo !! !!         string='123456 781-234-567' !!         write(*,*)'from ',string,' got ',luhn_checksum(string), & !!         & ' which should be 1234567812345670' !!      end subroutine checkem !!      end program demo_luhn_checksum !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== function luhn_checksum ( string ) use M_strings , only : transliterate ! ident_3=\"@(#)LUHN_CHECKSUM determines the Luhn checksum of a string composed of digits\" character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: luhn_checksum , string_local integer , allocatable :: dgts (:) integer :: n integer :: i integer :: value integer :: d2 integer :: ios string_local = transliterate ( string , ' -' , '' ) ! delete spaces and dashes n = len ( trim ( string_local )) ! Count the digits in string_local assuming the string_local is all digits. allocate ( dgts ( n )) read ( string_local , '(*(i1))' , iostat = ios )( dgts ( i ), i = 1 , n ) ! Extract the digits from S. if ( ios . ne . 0 ) then stop '*luhn_checksum* error reading digits' endif value = 0 do i = n , 1 , - 2 ! starting from the right double every other value and subtract 9 if the value is .gt. 9 and sum them d2 = dgts ( i ) * 2 value = value + merge ( d2 - 9 , d2 , d2 . gt . 9 ) enddo do i = n - 1 , 1 , - 2 ! add in the other values value = value + dgts ( i ) enddo value = mod ( value * 9 , 10 ) allocate ( character ( len = n + 1 ) :: luhn_checksum ) write ( luhn_checksum , '(a,i1)' ) string_local (: n ), value end function luhn_checksum !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_luhn_checksum () use M_strings , only : transliterate use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level use M_msg , only : str implicit none character ( len = :), allocatable :: ccards (:), string call unit_check_start ( 'luhn_checksum' , msg = '' ) ! good values ccards = [ character ( len = 20 ) :: '79927398713' , '49927398716' , '123456-781234567-0' , '4578 4230 1376 9219' ] call checkem (. true .) ! bad values ccards = [ character ( len = 20 ) :: & '79927398710' , '79927398711' , '79927398712' , '79927398714' , & '79927398715' , '79927398716' , '79927398717' , '79927398718' , '79927398719' , & '49927398717' , '1234567812345678' ] call checkem (. false .) call unit_check_done ( 'luhn_checksum' , msg = '' ) contains subroutine checkem ( goodbad ) logical , intent ( in ) :: goodbad integer :: i , j ! validate these numbers do i = 1 , size ( ccards ) j = len ( trim ( ccards ( i ))) string = luhn_checksum ( ccards ( i )(: j - 1 )) call unit_check ( 'luhn_checksum' , & ( transliterate ( ccards ( i ), ' -' , '' ). eq . string ). eqv . goodbad , & msg = str ( 'input' , ccards ( i )(: j - 1 ), 'output' , string )) enddo end subroutine checkem end subroutine test_luhn_checksum !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    djb2_hash(3f) - [M_hashkeys:bucket_hash] djb2 string hash (algorithm by Daniel J. Bernstein) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function djb2_hash_arr(anything,continue) result(hash_128) !! !!     class(*),intent(in)          :: anything(:) !!     logical,intent(in),optional  :: continue !!     !! use,intrinsic : ISO_FORTRAN_ENV, only : int64 !!     integer(kind=int128)         :: hash_128 !! !!##DESCRIPTION !!     djb2_hash(3f) is based on the string hash routine commonly known as !!     djb2(3c). This algorithm was first described by Dan J. Bernstein many !!     years ago in comp.lang.c. This version returns a value calculated !!     using a 64-bit hash, which is returned as a 128bit value (not always !!     available in Fortran) to allow the value to always be a positive !!     value; as Fortran does not (currently) support a standard unsigned !!     integer. If the value is changed to be a 64-bit value on platforms !!     that do not support 128-bit INTEGER values the value may be negative, !!     but is otherwise usable. !! !!     Such non-reversible hashes may be used for data or file fingerprints, !!     to confirm unchanging results during regression testing, ... !! !!     More information is widely available on string hashes (including the !!     well-known djb2(3c) algorithm) on such sources as Wikipedia. Consult !!     such resources to confirm the suitability of this algorithm for your !!     use. This algorithm was probably first proposed as a bucket hash. !! !!     The algorithm does not consider the Endian of the programming !!     environment. !! !!##OPTIONS !!     STR    May be a CHARACTER string or an array of common intrinsic !!            types. Currently, the types defined in the procedure !!            are character(len=*); complex; integer(kind=int8); !!            integer(kind=int16); integer(kind=int32); integer(kind=int64); !!            integer(kind=int128); real(kind=real32); real(kind=real64); !!            real(kind=real128). !! !!     CONTINUE   indicate whether to continue accumulating the hash value !!                from the last call. This is not threadsafe. This allows !!                for continued hashes so that a hash can be calculated for !!                a series of calls. !! !!##RETURNS !!     djb2_hash   A 128-bit INTEGER hash value for the (possibly accumulated) data. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_djb2_hash !!     use M_hashkeys, only : djb2_hash, int128 !!     implicit none !!     integer(kind=int128)         :: hash !!     character(len=:),allocatable :: string !!     integer                      :: i !!     ! string !!     string='test djb2_hash' !!     hash=djb2_hash(string) !!     write(*,*)'string=',string,' hash=',hash !!     ! array of characters !!     hash=djb2_hash(['t','e','s','t',' ','d','j','b','2','_','h','a','s','h']) !!     write(*,*)'string=',string,' hash=',hash !!     ! continued hash !!     hash=djb2_hash(['t','e','s','t']) !!     hash=djb2_hash([' ','d','j','b','2'],continue=.true.) !!     hash=djb2_hash(['_','h','a','s','h'],continue=.true.) !!     write(*,*)'string=',string,' hash=',hash !!     ! array of integers !!     hash=djb2_hash([(i,i=0,100)]) !!     write(*,*)'hash for values 0 to 100 is ',hash !!     ! !!     end program demo_djb2_hash function djb2_hash_arr ( anything , continue ) result ( hash_128 ) implicit none ! ident_4=\"@(#)djb2_hash(3fp): DJB2 hash of array (algorithm by Daniel J. Bernstein )\" class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue integer :: i integer ( kind = int128 ) :: hash_128 integer ( kind = int64 ), save :: hash_64 = 5381 character ( len = 1 ), allocatable :: chars (:) if ( present ( continue )) then hash_64 = hash_64 else hash_64 = 5381_int64 endif chars = anything_to_bytes ( anything ) do i = 1 , size ( chars ) hash_64 = ( ishft ( hash_64 , 5 ) + hash_64 ) + ichar ( chars ( i ), kind = int64 ) end do hash_128 = transfer ([ hash_64 , 0_int64 ], hash_128 ) if ( debug ) then DEBUG : block integer :: ios write ( 6 , '(\"*djb2_hash*       hashing string=\",*(a))' , advance = 'no' ) chars write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) hash_128 , hash_128 flush ( 6 , iostat = ios ) endblock DEBUG endif end function djb2_hash_arr !----------------------------------------------------------------------------------------------------------------------------------- function djb2_hash_scalar ( anything , continue ) result ( hash_128 ) implicit none ! ident_5=\"@(#)djb2_hash(3fp): djb2 hash of scalar\" class ( * ), intent ( in ) :: anything logical , intent ( in ), optional :: continue integer ( kind = int128 ) :: hash_128 character ( len = 1 ), allocatable :: chars (:) chars = anything_to_bytes ( anything ) if ( present ( continue )) then hash_128 = djb2_hash_arr ( chars , continue ) else hash_128 = djb2_hash_arr ( chars ) endif end function djb2_hash_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    crc32_hash(3f) - [M_hashkeys] CRC (Cyclic Redundancy Check) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   function crc32_hash(a,continue) result (crc) !! !!    class(*),intent(in)          :: anything(:) !!    logical,intent(in),optional  :: continue !!    integer(int64)               :: crc_out !! !!##DESCRIPTION !!    This ia 32-bit version of the Cyclic Redundancy Check(CRC). !!    This variant of CRC-32 uses LSB-first order, sets the initial CRC to !!    FFFFFFFF_int32, and complements the final CRC. !! !!    The result should be in accordance with ISO 3309, ITU-T V.42, Gzip !!    and PNG. !! !!##OPTIONS !!    anything  input value to generate a CRC check for. May be a array !!              or scalar of numeric or string values of type CHARACTER, !!              int8, int16, int32, int64, real32, real64, real128 !!    continue  optional parameter. If not present or .F. starts new !!              CRC sum. If .T. continues a CRC starting with last CRC !!              calculated. !!##RETURNS !!    crc       The calculated CRC sum. It is calculated as a 32-bit value !!              but returned as a 64-bit value, as Fortran does not !!              currently support unsigned integers. !! !!##REFERENCES !!    Algorithms are described in \"Computation of CRC\" in Wikipedia. !!    Also see !! !!       https://en.wikipedia.org/wiki/Cyclic_redundancy_check !! !!##AUTHOR !!    This was derived from an unattributed example on http://rosettacode.org, !!    but has been modified. !!##EXAMPLE !! !!   Sample program: !! !!    program demo_crc32_hash !!    use,intrinsic :: ISO_FORTRAN_ENV, only : int64 !!    use M_hashkeys, only : crc32_hash !!    implicit none !!    integer :: i !!    integer(int64) :: crc !!    character(*), parameter :: s = \"The quick brown fox jumps over the lazy dog\" !!       ! string !!       crc=crc32_hash(s) !!       print \"(Z8)\", crc !!       print \"(i0)\", crc !!       ! character array !!       print \"(i0)\", crc32_hash([ & !!               & 'T','h','e',' ',& !!               & 'q','u','i','c','k',' ',& !!               & 'b','r','o','w','n',' ',& !!               & 'f','o','x',' ']) !!       print \"(i0)\", crc32_hash([ & !!               & 'j','u','m','p','s',' ',& !!               & 'o','v','e','r',' ',& !!               & 't','h','e',' ',& !!               & 'l','a','z','y',' ',& !!               & 'd','o','g'],continue=.true.) !!       ! numeric array !!       print \"(i0)\", crc32_hash([(i,i=1,100)]) !!    end program demo_crc32_hash !! !!   Expected output: !! !!    414FA339 !!    1095738169 !!    2293265890 !!    1095738169 !!    1783575711 !! function crc32_hash_arr ( anything , continue ) result ( crc_64 ) use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none ! ident_6=\"@(#)M_hashkeys::crc32_hash_arr: CRC (Cyclic Redundancy Check) calculation\" class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue character ( len = 1 ), allocatable :: a (:) integer ( int64 ) :: crc_64 integer ( int32 ), save :: crc integer :: i integer ( int32 ), save :: crc_table ( 0 : 255 ) integer , save :: icalled = 0 if ( present ( continue )) then if ( continue . eqv . . false .) then crc = 0_int32 endif else crc = 0_int32 endif a = anything_to_bytes ( anything ) if ( icalled . eq . 0 ) then ! on first call generate table and use table for speed INIT_TABLE : block integer :: i , j integer ( int32 ) :: k do i = 0 , 255 k = i do j = 1 , 8 if ( btest ( k , 0 )) then k = ieor ( shiftr ( k , 1 ), - 306674912_int32 ) else k = shiftr ( k , 1 ) endif enddo crc_table ( i ) = k enddo endblock INIT_TABLE icalled = 1 endif crc = not ( crc ) do i = 1 , size ( a ) crc = ieor ( shiftr ( crc , 8 ), crc_table ( iand ( ieor ( crc , iachar ( a ( i ))), 255 ))) enddo crc = not ( crc ) crc_64 = transfer ([ crc , 0_int32 ], crc_64 ) if ( debug ) then DEBUG : block integer :: ios write ( 6 , '(\"*crc32_hash*       hashing string=\",*(a))' , advance = 'no' ) a write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) crc_64 , crc_64 ; flush ( 6 , iostat = ios ) endblock DEBUG endif end function crc32_hash_arr !----------------------------------------------------------------------------------------------------------------------------------- function crc32_hash_scalar ( anything , continue ) result ( hash_64 ) implicit none ! ident_7=\"@(#)crc32_hash_scalar(3fp): crc32 hash of scalar\" class ( * ), intent ( in ) :: anything logical , intent ( in ), optional :: continue integer ( kind = int64 ) :: hash_64 character ( len = 1 ), allocatable :: chars (:) chars = anything_to_bytes ( anything ) if ( present ( continue )) then hash_64 = crc32_hash_arr ( chars , continue ) else hash_64 = crc32_hash_arr ( chars ) endif end function crc32_hash_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    sdbm_hash(3f) - [M_hashkeys:bucket_hash] sdbm string hash !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    use,intrinsic : ISO_FORTRAN_ENV, only : int64 !!    function sdbm_hash_arr(anything,continue) result(hash_128) !! !!     class(*),intent(in)          :: anything(:) !!     logical,intent(in),optional  :: continue !!     integer(kind=int128)         :: hash_128 !! !!##DESCRIPTION !!    sdbm_hash(3f) is based on the string hash routine commonly known as !!    sdbm(3c). !! !!    this algorithm was created for the sdbm (a public-domain !!    reimplementation of ndbm) database library. It was found to do well !!    in scrambling bits, causing good distribution of the keys and fewer !!    splits. it also happens to be a good general hashing function with !!    good distribution. the actual function is !! !!       hash(i) = hash(i - 1) * 65599 + str[i] !! !!    what is available here is the faster version used !!    in gawk. [there is even a faster, duff-device version]. The magic !!    constant 65599 was picked out of thin air while experimenting with !!    different constants, and turns out to be a prime. this is one of the !!    algorithms used in berkeley db (see sleepycat) and elsewhere. !! !!    This version returns a value calculated using a 64-bit hash, which !!    is returned as a 128bit value (not always available in Fortran) to !!    allow the value to always be a positive value; as Fortran does not !!    (currently) support a standard unsigned integer. If the value is !!    changed to be a 64-bit value on platforms that do not support 128-bit !!    INTEGER values the value may be negative, but is otherwise usable. !! !!    Such non-reversible hashes may be used for data or file fingerprints, !!    to confirm unchanging results during regression testing, ... !! !!    More information is widely available on string hashes (including the !!    well-known sdbm(3c) algorithm) on such sources as Wikipedia. Consult !!    such resources to confirm the suitability of this algorithm for !!    your use. !! !!    The algorithm does not consider the Endian of the programming !!    environment. !! !!##OPTIONS !!     STR    May be a CHARACTER string or an array of common intrinsic !!            types. Currently, the types defined in the procedure !!            are character(len=*); complex; integer(kind=int8); !!            integer(kind=int16); integer(kind=int32); integer(kind=int64); !!            integer(kind=int128); real(kind=real32); real(kind=real64); !!            real(kind=real128). !! !!     CONTINUE   indicate whether to continue accumulating the hash value !!                from the last call. This is not threadsafe. This allows !!                for continued hashes so that a hash can be calculated for !!                a series of calls. !! !!##RETURNS !!     sdbm_hash   A 128-bit INTEGER hash value for the (possibly accumulated) data. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_sdbm_hash !!     use M_hashkeys, only : sdbm_hash, int128 !!     implicit none !!     integer(kind=int128)         :: hash !!     character(len=:),allocatable :: string !!     integer                      :: i !!     ! string !!     string='test sdbm_hash' !!     hash=sdbm_hash(string) !!     write(*,*)'string=',string,' hash=',hash !!     ! array of characters !!     hash=sdbm_hash(['t','e','s','t',' ','s','d','b','m','_','h','a','s','h']) !!     write(*,*)'string=',string,' hash=',hash !!     ! continued hash !!     hash=sdbm_hash(['t','e','s','t']) !!     hash=sdbm_hash([' ','s','d','b','m'],continue=.true.) !!     hash=sdbm_hash(['_','h','a','s','h'],continue=.true.) !!     write(*,*)'string=',string,' hash=',hash !!     ! array of integers !!     hash=sdbm_hash([(i,i=0,100)]) !!     write(*,*)'hash for values 0 to 100 is ',hash !!     ! !!     end program demo_sdbm_hash function sdbm_hash_arr ( anything , continue ) result ( hash_128 ) use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none ! ident_8=\"@(#)sdbm_hash_arr(3fp): sdbm hash of array\" class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue integer :: i integer ( kind = int128 ) :: hash_128 integer ( kind = int64 ), save :: hash_64 = 5381 character ( len = 1 ), allocatable :: chars (:) if ( present ( continue )) then hash_64 = hash_64 else hash_64 = 0_int64 endif chars = anything_to_bytes ( anything ) do i = 1 , size ( chars ) hash_64 = ichar ( chars ( i ), kind = int64 ) + ishft ( hash_64 , 6 ) + ishft ( hash_64 , 16 ) - hash_64 end do hash_128 = transfer ([ hash_64 , 0_int64 ], hash_128 ) if ( debug ) then DEBUG : block integer :: ios write ( 6 , '(\"*sdbm_hash*       hashing string=\",*(a))' , advance = 'no' ) chars write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) hash_128 , hash_128 ; flush ( 6 , iostat = ios ) endblock DEBUG endif end function sdbm_hash_arr !----------------------------------------------------------------------------------------------------------------------------------- function sdbm_hash_scalar ( anything , continue ) result ( hash_128 ) implicit none ! ident_9=\"@(#)sdbm_hash_scalar(3fp): sdbm hash of scalar\" class ( * ), intent ( in ) :: anything logical , intent ( in ), optional :: continue integer ( kind = int128 ) :: hash_128 character ( len = 1 ), allocatable :: chars (:) chars = anything_to_bytes ( anything ) if ( present ( continue )) then hash_128 = sdbm_hash_arr ( chars , continue ) else hash_128 = sdbm_hash_arr ( chars ) endif if ( debug ) then DEBUG : block integer :: i integer :: ios write ( 6 , '(\"*sdbm scalar          hashing string=\",*(a))' , advance = 'no' )( chars ( i ), i = 1 , size ( chars )) write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) hash_128 , hash_128 flush ( 6 , iostat = ios ) endblock DEBUG endif end function sdbm_hash_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function djb2 ( anything ) implicit none ! ident_10=\"@(#)djb2(3f): call C routine djb2(3c) with a Fortran CHARACTER variable\" ! extern int djb2(char *s); interface function djb2_F ( S ) bind ( C , NAME = 'C_djb2' ) use ISO_C_BINDING , only : C_LONG , C_CHAR implicit none integer ( KIND = C_LONG ) :: djb2_F character ( KIND = C_CHAR ), intent ( in ) :: S ( * ) end function djb2_F end interface class ( * ), intent ( in ) :: anything (:) integer ( kind = int128 ) :: djb2 character ( len = 1 ), allocatable :: chars (:) chars = anything_to_bytes ( anything ) djb2 = transfer ([ djb2_F ([ chars , char ( 0 )]), 0_int64 ], djb2 ) if ( debug ) then DEBUG : block integer :: i integer :: ios write ( 6 , '(\"*djb2 FORTRAN*        hashing string=\",*(a))' , advance = 'no' )( chars ( i ), i = 1 , size ( chars )) write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) djb2 , djb2 flush ( 6 , iostat = ios ) endblock DEBUG endif end function djb2 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   b3hs_hash_key_jenkins(3f) - [M_hashkeys] hash key algorithm by Bob Jenkins !!   (LICENSE:PD) !! !!##SYNOPSIS !! !!   function b3hs_hash_key_jenkins (key, range) result (code) !! !!    character(*), intent(in) :: key !!    integer, intent(in)      :: range !!    integer                  :: code !! !!##DESCRIPTION !!   Based on implementation of Bob Jenkins hash function by Rich Townsen, !!   posted 2008-03-23 at !! !!      http://computer-programming-forum.com/49-fortran/0596e59d0fa2e5e4.htm !! !!##OPTIONS !!   KEY    string to generate a hash key for !!   RANGE  range should be a power of 2. Note that the 32-bit algorithm is used !! !!##RETURNS !!   CODE   returned hash value in range specified by RANGE function b3hs_hash_key_jenkins ( key , range ) result ( code ) character ( * ), intent ( in ) :: key integer , intent ( in ) :: range integer :: code integer :: len_key integer ( int32 ) :: a integer ( int32 ) :: b integer ( int32 ) :: c integer :: k ! Hash the key into a code, using the algorithm described by Bob Jenkins at: !  http://burtleburtle.net/bob/hash/doobs.html ! ! Note that range should be a power of 2, and that the 32-bit algorithm is used len_key = LEN_TRIM ( key ) a = - 1640531527_int32 ! 0x9E3779B9 b = a c = 305419896_int32 ! 0x12345678 k = 1 char_loop : do if ( len_key < 12 ) exit char_loop ! Pack the key into 32 bits a = a + ICHAR ( key ( k + 0 : k + 0 )) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) c = c + ICHAR ( key ( k + 8 : k + 8 )) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 16 ) + ISHFT ( ICHAR ( key ( k + 11 : k + 11 )), 24 ) ! Mix it up call b3hs_hash_key_jenkins_mix_ () k = k + 12 len_key = len_key - 12 end do char_loop c = c + len_key ! Process remaining bits select case ( len_key ) case ( 11 ) c = c + ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 24 ) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 10 ) c = c + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 9 ) c = c + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 7 ) b = b + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 6 ) b = b + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 5 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 4 ) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 3 ) a = a + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ICHAR ( key ( k : k )) case ( 2 ) a = a + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 1 ) a = a + ICHAR ( key ( k : k )) end select call b3hs_hash_key_jenkins_mix_ () code = IAND ( c , range - 1 ) + 1 ! Finish contains subroutine b3hs_hash_key_jenkins_mix_ ! Mix a, b and c a = IEOR ( a - b - c , ISHFT ( c , - 13 )) b = IEOR ( b - c - a , ISHFT ( a , 8 )) c = IEOR ( c - a - b , ISHFT ( b , - 13 )) a = IEOR ( a - b - c , ISHFT ( c , - 12 )) b = IEOR ( b - c - a , ISHFT ( a , 16 )) c = IEOR ( c - a - b , ISHFT ( b , - 5 )) a = IEOR ( a - b - c , ISHFT ( c , - 3 )) b = IEOR ( b - c - a , ISHFT ( a , 10 )) c = IEOR ( c - a - b , ISHFT ( b , - 15 )) ! Finish end subroutine b3hs_hash_key_jenkins_mix_ end function b3hs_hash_key_jenkins !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine test_suite_M_hashkeys call test_luhn_checksum () end subroutine test_suite_M_hashkeys !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function anything_to_bytes_arr ( anything ) result ( chars ) implicit none ! ident_11=\"@(#)M_anything::anything_to_bytes_arr(3fp): any vector of intrinsics to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything (:) character ( len = 1 ), allocatable :: chars (:) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) type is ( logical ); chars = transfer ( anything , chars ) class default stop 'crud. anything_to_bytes_arr(1) does not know about this type' end select end function anything_to_bytes_arr !----------------------------------------------------------------------------------------------------------------------------------- function anything_to_bytes_scalar ( anything ) result ( chars ) implicit none ! ident_12=\"@(#)M_anything::anything_to_bytes_scalar(3fp): anything to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything character ( len = 1 ), allocatable :: chars (:) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) type is ( logical ); chars = transfer ( anything , chars ) class default stop 'crud. anything_to_bytes_scalar(1) does not know about this type' end select end function anything_to_bytes_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_hashkeys !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_hashkeys.f90.html"},{"title":"hasher.f90 – M_hashkeys","text":"Contents Programs hash_exe Subroutines help_usage help_version Source Code hasher.f90 Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   hasher(1f) - [M_hashkeys] exercise the string hash methods in the M_hashkey(3fm) module                                      ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version                                            ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   hasher(1f) does a byte by byte hash of a file or a hash of a string                                                          ' ,& '   using the procedures available in the M_hashkey(3fm) module. It is up                                                        ' ,& '   to the user to determine if the method is suitable for a specific use.                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   input_files  files to generate a hash for                                                                                    ' ,& '   hash         name of hash algorithm. Currently allowed                                                                       ' ,& '                values are:                                                                                                     ' ,& '                                                                                                                                ' ,& '                  djb2 (default)   calls djb2_hash(3f)                                                                          ' ,& '                  sdbm             calls sdbm_hash(3f)                                                                          ' ,& '                  crc32            calls cfc32_hash(3f)                                                                         ' ,& '                                                                                                                                ' ,& '   --help       display this help and exit                                                                                      ' ,& '   --version    output version information and exit                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        hasher(1f)>' ,& '@(#)DESCRIPTION:    string hash example>' ,& '@(#)VERSION:        20180928>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to>' ,& '@(#)                change and redistribute it.  There is NO WARRANTY;>' ,& '@(#)                without even the implied warranty of MERCHANTABILITY or>' ,& '@(#)                FITNESS FOR A PARTICULAR PURPOSE.>' ,& '@(#)COMPILED:       2022-07-15 22:15:47 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version program hash_exe use , intrinsic :: iso_fortran_env , only : ERROR_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : iostat_end use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_hashkeys , only : djb2_hash , int128 use M_hashkeys , only : sdbm_hash use M_hashkeys , only : crc32_hash use M_kracken , only : kracken , lget , sget , sgets use M_system , only : system_isreg use M_verify , only : debug implicit none integer :: i integer :: ios integer :: icount integer ( kind = int128 ) :: hash integer , parameter :: IUNIT = 15 ! input file unit character ( len = :), allocatable :: string character ( len = 4096 ), allocatable :: filenames (:) character ( len = 4096 ) :: msg character ( len = :), allocatable :: hashname logical :: cont integer , parameter :: bufsize = 1048576 * 32 character ( len = 1 ) :: buff ( bufsize ) integer :: sz integer :: filepoint abstract interface function hashkey ( anything , continue ) import int128 integer ( kind = int128 ) :: hashkey class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue end function hashkey end interface procedure ( hashkey ), pointer :: hash_ptr => null () !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'hasher' , ' -hash djb2 -string -version F -help F -verbose F' ) ! crack command-line call help_usage ( lget ( 'hasher_help' )) ! check if help requested call help_version ( lget ( 'hasher_version' )) ! check if version requested string = trim ( sget ( 'hasher_string' )) filenames = sgets ( 'hasher_oo' ) debug = lget ( 'hasher_verbose' ) hashname = trim ( sget ( 'hasher_hash' )) !!  select case(hashname)                                                       ! point to selected function !!  case('djb2'); hash_ptr => djb2_hash !!  case('sdbm'); hash_ptr => sdbm_hash !!  case default !!     write(ERROR_UNIT,*)'*hasher* error: unknown hash method ' !!     stop 3 !!  end select !----------------------------------------------------------------------------------------------------------------------------------- if ( string . ne . '' ) then !!write(*,'(i0,1x,a)')hash_ptr(string),trim(string) select case ( hashname ) ! point to selected function case ( 'skip' ) ; write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , 0 , len ( string ), string case ( 'djb2' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , djb2_hash ( string ) , len ( string ), string case ( 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , sdbm_hash ( string ) , len ( string ), string case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , crc32_hash ( string ) , len ( string ), string case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 2 end select endif !----------------------------------------------------------------------------------------------------------------------------------- if ( debug ) then write ( * , * ) 'FILES=' ,( trim ( filenames ( i )), i = 1 , size ( filenames )) endif !----------------------------------------------------------------------------------------------------------------------------------- FILES : do i = 1 , size ( filenames ) ! open file if it is a regular file if (. not . system_isreg ( filenames ( i ))) cycle open ( unit = IUNIT , file = filenames ( i ), status = 'old' , access = 'stream' , iostat = ios , iomsg = msg , action = 'read' ) if ( ios . ne . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' message=' , trim ( msg ) close ( unit = IUNIT , iostat = ios ) cycle FILES endif cont = . false . ! for initial call use default seed icount = 0 ! count number of characters processed sz = bufsize filepoint = 1 hash = 0_int128 INFINITE : do ! read and sum file string by string ! quick buffering read because reading a single character sixty times slower on CygWIn with gfortran (no system buffering?) read ( iunit , iostat = ios , pos = filepoint ) buff ( 1 : sz ) if ( is_iostat_end ( ios )) then ! this is the last buffer if ( sz . ne . 1 ) then ! try again with a smaller buffer sz = max ( 1 , sz / 2 ) cycle INFINITE endif elseif ( ios == 0 ) then ! no error occurred so successfully read a buffer filepoint = filepoint + sz endif if ( ios /= 0 ) then ! quit reading on error exit INFINITE endif !!hash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash select case ( hashname ) ! point to selected function case ( 'skip' ); case ( 'djb2' ); hash = djb2_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'sdbm' ); hash = sdbm_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'crc32' ); hash = crc32_hash ( buff (: sz ), continue = cont ) ! build up hash case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 1 end select icount = icount + sz if ( cont . eqv .. false .) cont = . true . ! change flag to continue hash build after first call to accumulate enddo INFINITE if ( icount . eq . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' is empty' else select case ( hashname ) ! point to selected function case ( 'djb2' , 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'skip' ); hash = 0_int128 write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) end select endif close ( unit = IUNIT , iostat = ios ) enddo FILES end program hash_exe","tags":"","loc":"sourcefile/hasher.f90.html"},{"title":"sha3.f90 – M_hashkeys","text":"Contents Programs demo_M_sha3 Source Code sha3.f90 Source Code ! NAME !    sha3(1) - [FUNIX:M_strings] generate SHA-256 digest values for specified files !    (LICENSE:PD) ! ! SYNOPSIS !        sha3 [-224|-256|-384|-512|-a] FILE... ! ! DESCRIPTION !    Example of using M_sha3(3fm) module. Calculates SHA digest values for specified files. ! !    NOT CURRENTLY WORKING ! ! OPTIONS !    -224     calculate SHA-224 digest values for specified files !    -256     calculate SHA-224 digest values for specified files(default) !    -384     calculate SHA-224 digest values for specified files !    -512     calculate SHA-224 digest values for specified files !    -a       run internal tests of routines in M_sha3(3fm) module !    FILE(S)  names of files to generate a hash for. ! ! EXAMPLES !   Sample usage !      sha3 * ! program demo_M_sha3 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_sha3 , only : sha3_auto_test , sha3_file use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha3(1f): generate SHA-256 digest values for specified files\" integer :: i integer :: start character ( len = 4096 ) :: fname , arg call get_command_argument ( 1 , arg ) if ( trim ( arg ) . eq . '-a' ) then call sha3_auto_test () elseif ( arg ( 1 : 1 ) . eq . '-' ) then start = 2 else start = 1 arg = '-256' endif do i = start , command_argument_count () ! step through filenames on command line call get_command_argument ( i , fname ) if (. not . system_isreg ( fname )) cycle select case ( arg ) case ( '-224' ) ; call sha3_file ( 224 , trim ( fname ) ) case ( '-256' ) ; call sha3_file ( 256 , trim ( fname ) ) case ( '-384' ) ; call sha3_file ( 384 , trim ( fname ) ) case ( '-512' ) ; call sha3_file ( 512 , trim ( fname ) ) case default write ( ERROR_UNIT , * ) '\"usage: \"sha3 -a\" or \"sha3 [ -224| -256| -384| -512] fname\"' end select enddo end program demo_M_sha3","tags":"","loc":"sourcefile/sha3.f90.html"},{"title":"main.f90 – M_hashkeys","text":"Contents Programs main Source Code main.f90 Source Code program main implicit none print * , \"hello from project M_hashkeys\" end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"digest.f90 – M_hashkeys","text":"Contents Programs demo_sha256 Source Code digest.f90 Source Code ! NAME !    digest(1f) - [FUNIX] compute SHA256 message digest !    (LICENSE:PD) ! ! SYNOPSIS !    digest FILE... ! ! DESCRIPTION !    digest(1f) prints SHA256 (256-bit) checksums. The sums are computed !    as described in FIPS-180-2. For each regular file listed on the !    command line a line is printed with the checksum, a byte count and !    the name of the file. ! !    It exercises the sha256(3f) routine. Note that it reads the files !    one at a time into dynamically allocated memory. ! ! EXAMPLES !    Sample commands ! !     digest  * !      FF1A6FB5327CBCEB6E32BCAB543FA71C3033C196EB84E122722C3FD6208360FF     1049831 c1-1-tirupathi.pdf !      F61B2FF27B5268B9FB6DAD7BBA76D1072D046349D7E767BEEFC3AB2CA72CA95B      109119 in-1 !      B01911225398AC1371DF8F1D72CBE8AA2E677EDD855E830B2E073439057202EA        4591 newbugs.f90 !      52E4A0D9ACDD801D62AD497D57B143E5A2E0A56EAD0EA587D14F299EDBC3C8C9        4505 record.sh ! ! AUTHOR !    John S. Urban ! ! LICENSE ! Public Domain program demo_sha256 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_hashkeys , only : sha256 , test_suite_sha256 use M_io , only : slurp use M_strings , only : switch use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha256(1f): read file into memory and generate SHA-256 digest value\" character ( len = 1 ), allocatable :: text (:) ! array to hold file in memory character ( len = :), allocatable :: string integer :: i = 0 character ( len = 4096 ) :: filename do i = 1 , command_argument_count () ! step through filenames on command line call get_command_argument ( i , filename ) if (. not . system_isreg ( filename )) cycle ! ignore anything except regular files call slurp ( filename , text ) ! allocate character array and copy file into it if (. not . allocated ( text )) then write ( ERROR_UNIT , * ) '*sha256* ERROR: failed to load file ' // trim ( filename ) else string = switch ( text ) ! switch array to a single character variable deallocate ( text ) ! release memory write ( * , * ) sha256 ( string ), len ( string ), trim ( filename ) ! write digest value endif enddo if ( i . le . 1 ) call test_suite_sha256 () end program demo_sha256","tags":"","loc":"sourcefile/digest.f90.html"},{"title":"demo_M_sha3.f90 – M_hashkeys","text":"Contents Programs demo_M_sha3 Source Code demo_M_sha3.f90 Source Code program demo_M_sha3 use M_sha3 implicit none character ( len = 128 ) :: fname , arg call get_command_argument ( 1 , arg ) if ( arg ( 1 : 1 ) . eq . '-' ) then if ( trim ( arg ) . eq . '-a' ) then call sha3_auto_test () else call get_command_argument ( 2 , fname ) select case ( trim ( arg )) case ( '-224' ); call sha3_file ( 224 , trim ( fname ) ) case ( '-256' ); call sha3_file ( 256 , trim ( fname ) ) case ( '-384' ); call sha3_file ( 384 , trim ( fname ) ) case ( '-512' ); call sha3_file ( 512 , trim ( fname ) ) case default print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' end select endif else print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' endif end program demo_M_sha3","tags":"","loc":"sourcefile/demo_m_sha3.f90.html"},{"title":"demo_sdbm_hash.f90 – M_hashkeys","text":"Contents Programs demo_sdbm_hash Source Code demo_sdbm_hash.f90 Source Code program demo_sdbm_hash use M_hashkeys , only : sdbm_hash , int128 implicit none integer ( kind = int128 ) :: hash character ( len = :), allocatable :: string integer :: i ! string string = 'test sdbm_hash' hash = sdbm_hash ( string ) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of characters hash = sdbm_hash ([ 't' , 'e' , 's' , 't' , ' ' , 's' , 'd' , 'b' , 'm' , '_' , 'h' , 'a' , 's' , 'h' ]) write ( * , * ) 'string=' , string , ' hash=' , hash ! continued hash hash = sdbm_hash ([ 't' , 'e' , 's' , 't' ]) hash = sdbm_hash ([ ' ' , 's' , 'd' , 'b' , 'm' ], continue = . true .) hash = sdbm_hash ([ '_' , 'h' , 'a' , 's' , 'h' ], continue = . true .) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of integers hash = sdbm_hash ([( i , i = 0 , 100 )]) write ( * , * ) 'hash for values 0 to 100 is ' , hash ! end program demo_sdbm_hash","tags":"","loc":"sourcefile/demo_sdbm_hash.f90.html"},{"title":"demo_djb2_hash.f90 – M_hashkeys","text":"Contents Programs demo_djb2_hash Source Code demo_djb2_hash.f90 Source Code program demo_djb2_hash use M_hashkeys , only : djb2_hash , int128 implicit none integer ( kind = int128 ) :: hash character ( len = :), allocatable :: string integer :: i ! string string = 'test djb2_hash' hash = djb2_hash ( string ) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of characters hash = djb2_hash ([ 't' , 'e' , 's' , 't' , ' ' , 'd' , 'j' , 'b' , '2' , '_' , 'h' , 'a' , 's' , 'h' ]) write ( * , * ) 'string=' , string , ' hash=' , hash ! continued hash hash = djb2_hash ([ 't' , 'e' , 's' , 't' ]) hash = djb2_hash ([ ' ' , 'd' , 'j' , 'b' , '2' ], continue = . true .) hash = djb2_hash ([ '_' , 'h' , 'a' , 's' , 'h' ], continue = . true .) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of integers hash = djb2_hash ([( i , i = 0 , 100 )]) write ( * , * ) 'hash for values 0 to 100 is ' , hash ! end program demo_djb2_hash","tags":"","loc":"sourcefile/demo_djb2_hash.f90.html"},{"title":"demo_crc32_hash.f90 – M_hashkeys","text":"Contents Programs demo_crc32_hash Source Code demo_crc32_hash.f90 Source Code program demo_crc32_hash use , intrinsic :: ISO_FORTRAN_ENV , only : int64 use M_hashkeys , only : crc32_hash implicit none integer :: i integer ( int64 ) :: crc character ( * ), parameter :: s = \"The quick brown fox jumps over the lazy dog\" ! string crc = crc32_hash ( s ) print \"(Z8)\" , crc print \"(i0)\" , crc ! character array print \"(i0)\" , crc32_hash ([ & & 'T' , 'h' , 'e' , ' ' ,& & 'q' , 'u' , 'i' , 'c' , 'k' , ' ' ,& & 'b' , 'r' , 'o' , 'w' , 'n' , ' ' ,& & 'f' , 'o' , 'x' , ' ' ]) print \"(i0)\" , crc32_hash ([ & & 'j' , 'u' , 'm' , 'p' , 's' , ' ' ,& & 'o' , 'v' , 'e' , 'r' , ' ' ,& & 't' , 'h' , 'e' , ' ' ,& & 'l' , 'a' , 'z' , 'y' , ' ' ,& & 'd' , 'o' , 'g' ], continue = . true .) ! numeric array print \"(i0)\" , crc32_hash ([( i , i = 1 , 100 )]) end program demo_crc32_hash","tags":"","loc":"sourcefile/demo_crc32_hash.f90.html"},{"title":"demo_luhn_checksum.f90 – M_hashkeys","text":"Contents Programs demo_luhn_checksum Source Code demo_luhn_checksum.f90 Source Code program demo_luhn_checksum use M_hashkeys , only : luhn_checksum implicit none character ( len = :), allocatable :: ccards (:), string integer :: i , j write ( * , * ) 'GOOD VALUES' ccards = [ character ( len = 20 ) :: '79927398713' , & & '49927398716' ,& & '1234567812345670' ] call checkem () write ( * , * ) 'BAD VALUES' ccards = [ character ( len = 20 ) :: & & '79927398710' , '79927398711' , '79927398712' , '79927398714' , & & '79927398715' , '79927398716' , '79927398717' , '79927398718' , & & '79927398719' , & '49927398717' , '1234567812345678' ] call checkem () contains subroutine checkem ! validate these numbers do i = 1 , size ( ccards ) j = len ( trim ( ccards ( i ))) string = luhn_checksum ( ccards ( i )(: j - 1 )) write ( * , '(a,1x,a,1x,l1)' ) ccards ( i ), string , ccards ( i ). eq . string enddo string = '123456 781-234-567' write ( * , * ) 'from ' , string , ' got ' , luhn_checksum ( string ), & & ' which should be 1234567812345670' end subroutine checkem end program demo_luhn_checksum","tags":"","loc":"sourcefile/demo_luhn_checksum.f90.html"},{"title":"test_suite_M_hashkeys.f90 – M_hashkeys","text":"Contents Programs runtest Source Code test_suite_M_hashkeys.f90 Source Code program runtest use M_hashkeys , only : test_suite_M_hashkeys use M_hashkeys , only : test_suite_sha256 use M_verify unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 write ( * , * ) 'STARTED test_suite_M_hashkeys' call test_suite_M_hashkeys () call test_suite_sha256 () write ( * , * ) 'COMPLETEDtest_suite_ M_hashkeys' end program runtest","tags":"","loc":"sourcefile/test_suite_m_hashkeys.f90.html"},{"title":"test_suite_M_sha3.f90 – M_hashkeys","text":"Contents Programs runtest Source Code test_suite_M_sha3.f90 Source Code program runtest use M_sha3 , only : test_suite_M_sha3 use M_verify unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 write ( * , * ) 'STARTED test_suite_M_sha3' call test_suite_M_sha3 () write ( * , * ) 'COMPLETEDtest_suite_ M_sha3' end program runtest","tags":"","loc":"sourcefile/test_suite_m_sha3.f90.html"},{"title":"sha3_state – M_hashkeys ","text":"type, public :: sha3_state Contents Variables S buffer bufsize c d r Source Code sha3_state Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(5,5) :: S integer(kind=int8), public, dimension(:), pointer :: buffer integer, public :: bufsize = -1 integer, public :: c integer, public :: d integer, public :: r Source Code type sha3_state integer :: d ! size of digest in bits integer :: c ! capacity in bits integer :: r ! rate, in bits integer ( kind = int64 ), dimension ( 5 , 5 ) :: S ! state integer ( kind = int8 ), dimension (:), pointer :: buffer integer :: bufsize = - 1 ! the number of bytes actually usable in buffer end type sha3_state","tags":"","loc":"type/sha3_state.html"},{"title":"hashkey – M_hashkeys","text":"abstract interface function hashkey(anything, continue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128)","tags":"","loc":"interface/hashkey.html"},{"title":"help_usage – M_hashkeys","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   hasher(1f) - [M_hashkeys] exercise the string hash methods in the M_hashkey(3fm) module                                      ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version                                            ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   hasher(1f) does a byte by byte hash of a file or a hash of a string                                                          ' ,& '   using the procedures available in the M_hashkey(3fm) module. It is up                                                        ' ,& '   to the user to determine if the method is suitable for a specific use.                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   input_files  files to generate a hash for                                                                                    ' ,& '   hash         name of hash algorithm. Currently allowed                                                                       ' ,& '                values are:                                                                                                     ' ,& '                                                                                                                                ' ,& '                  djb2 (default)   calls djb2_hash(3f)                                                                          ' ,& '                  sdbm             calls sdbm_hash(3f)                                                                          ' ,& '                  crc32            calls cfc32_hash(3f)                                                                         ' ,& '                                                                                                                                ' ,& '   --help       display this help and exit                                                                                      ' ,& '   --version    output version information and exit                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage.html"},{"title":"help_version – M_hashkeys","text":"subroutine help_version(l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        hasher(1f)>' ,& '@(#)DESCRIPTION:    string hash example>' ,& '@(#)VERSION:        20180928>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to>' ,& '@(#)                change and redistribute it.  There is NO WARRANTY;>' ,& '@(#)                without even the implied warranty of MERCHANTABILITY or>' ,& '@(#)                FITNESS FOR A PARTICULAR PURPOSE.>' ,& '@(#)COMPILED:       2022-07-15 22:15:47 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version.html"},{"title":"sha3 – M_hashkeys","text":"public function sha3(buffer, d) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: buffer integer, intent(in) :: d Return Value integer(kind=int8),\n  dimension(d/8) Contents Source Code sha3 Source Code function sha3 ( buffer , d ) ! SHA3 can produce variable-length digests, having length d in bits ! we assume that d is a multiple of 8 integer ( kind = int8 ), dimension (:), intent ( in ) :: buffer integer , intent ( in ) :: d ! output length integer ( kind = int8 ), dimension ( d / 8 ) :: sha3 select case ( d ) case ( 224 ) ! SHA3 224 sha3 = sha3_keccak ( buffer , 224 , 448 ) case ( 256 ) ! SHA3 256 sha3 = sha3_keccak ( buffer , 256 , 512 ) case ( 384 ) ! SHA3 384 sha3 = sha3_keccak ( buffer , 384 , 768 ) case ( 512 ) ! SHA3 512 sha3 = sha3_keccak ( buffer , 512 , 1024 ) case default if ( d > 0 ) then sha3 = sha3_keccak ( buffer , d , 256 ) else sha3 = sha3_keccak ( buffer , - d , 512 ) endif end select end function sha3","tags":"","loc":"proc/sha3.html"},{"title":"sha3_hexdigest – M_hashkeys","text":"public function sha3_hexdigest(d) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: d Return Value character(len=size(d)*2) Contents Source Code sha3_hexdigest Source Code function sha3_hexdigest ( d ) ! returns a digest d (a list of bytes) as an hexadecimal string integer ( kind = int8 ), dimension (:), intent ( in ) :: d character ( len = size ( d ) * 2 ) :: sha3_hexdigest write ( sha3_hexdigest , '(100Z2.2)' ) d end function sha3_hexdigest","tags":"","loc":"proc/sha3_hexdigest.html"},{"title":"sha3_auto_test – M_hashkeys","text":"public subroutine sha3_auto_test() Arguments None Contents Subroutines sha3_test11 sha3_test21 sha3_test31 sha3_test41 sha3_test51 sha3_test61 Source Code sha3_auto_test Subroutines subroutine sha3_test11() Arguments None subroutine sha3_test21() Arguments None subroutine sha3_test31() Arguments None subroutine sha3_test41() Arguments None subroutine sha3_test51() Arguments None subroutine sha3_test61() Arguments None Source Code subroutine sha3_auto_test () !call sha3_test11() call sha3_test21 () call sha3_test31 () call sha3_test41 () call sha3_test51 () call sha3_test61 () contains !================================================================================ subroutine sha3_test11 () !================================================================================ integer ( kind = int8 ), dimension ( 512 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST11  : hash empty string' print '(a,a128)' , '         ' , sha3_hexdigest ( sha3 ( buffer , 512 )) allocate ( buffer ( 0 ) ) call sha3_update ( S , buffer , 512 ) call sha3_digest ( S , digest ) print '(a,a128)' , '         ' , sha3_hexdigest ( digest ) print '(a,2a128)' , '         A69F73CCA23A9AC5C8B567DC185A756E97C982164FE25859E0D1DCC1475C80' , & 'A615B2123AF1F5F94C11E3E9402C3AC558F500199D95B6D3E301758586281DCD26' end subroutine sha3_test11 !================================================================================ subroutine sha3_test21 () !================================================================================ character ( len = 1024 ) :: m integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST21  : hash \"abc\"' m = 'abc' allocate ( buffer ( len_trim ( m )) ) buffer = transfer ( trim ( m ), buffer ) print * , '        ' , sha3_hexdigest ( sha3 ( buffer , 224 ) ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) print * , '        ' , sha3_hexdigest ( digest ) print * , '        E642824C3F8CF24AD09234EE7D3C766FC9A3A5168D0C94AD73B46FDF' deallocate ( buffer ) end subroutine sha3_test21 !================================================================================ subroutine sha3_test31 () !================================================================================ character ( len = 1024 ) :: m integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S print * print * , 'TEST31  : hash \"abc...stu\"' m = 'abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu' allocate ( buffer ( len_trim ( m )) ) buffer = transfer ( trim ( m ), buffer ) print * , '        ' , sha3_hexdigest ( sha3 ( buffer , 224 ) ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) print * , '        ' , sha3_hexdigest ( digest ) print * , '        543E6868E1666C1A643630DF77367AE5A62A85070A51C14CBF665CBC' deallocate ( buffer ) end subroutine sha3_test31 !================================================================================ subroutine sha3_test41 () !================================================================================ integer , parameter :: N = 1000 * 1000 integer , parameter :: M = 100 integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S integer :: i , j real :: t1 , t2 , d1 , d2 , d3 print * print * , 'TEST41  : hash \"a\"*' , N allocate ( buffer ( N ) ) do i = 1 , N buffer ( i ) = 97_int8 enddo call cpu_time ( t1 ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) call cpu_time ( t2 ) d1 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) call cpu_time ( t1 ) digest = sha3 ( buffer , 224 ) call cpu_time ( t2 ) d2 = t2 - t1 ! now provide it in small packets call cpu_time ( t1 ) j = 0 do i = 1 , N / M call sha3_update ( S , buffer ( j + 1 : j + M ) ) j = j + M enddo call sha3_digest ( S , digest ) call cpu_time ( t2 ) d3 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) print * , '        D69335B93325192E516A912E6D19A15CB51C6ED5C15243E7A7FD653C' deallocate ( buffer ) !print *, 'timings: ', d1, d2, d3 !call sha3_file( 'sha3.f90', 224, digest ) end subroutine sha3_test41 !================================================================================ subroutine sha3_test51 () !================================================================================ integer :: i , j character ( len = 128 ) :: digest , fname , fname2 character ( len = 256 ) :: line integer , dimension ( 4 ) :: dv , mds dv = ( / 224 , 256 , 384 , 512 / ) mds = ( / 56 , 64 , 96 , 128 / ) print * print * , 'TEST 51 : hash files and compare digests with reference' ! loop on test vectors do i = 1 , 5 write ( fname2 , '(a,i3.3,a)' ) 'test_vectors/test_' , i , '.digests' open ( unit = 12 , file = trim ( fname2 ) ) print * , '   file #' , i ! loop on SHA3 variant do j = 1 , 4 write ( fname , '(a,i3.3,a)' ) 'test_vectors/test_' , i , '.msg' call sha3_file ( dv ( j ), fname , digest ) write ( * , '(10x,i3,1x,a)' ) dv ( j ), trim ( digest ) read ( 12 , '(a)' ) line write ( * , '(10x,a)' ) trim ( line ) print * enddo close ( 12 ) print * enddo end subroutine sha3_test51 !================================================================================ subroutine sha3_test61 () !================================================================================ integer , parameter :: N = 100 * 1024 * 1024 integer ( kind = int8 ), dimension ( 224 / 8 ) :: digest integer ( kind = int8 ), dimension (:), allocatable :: buffer type ( sha3_state ) :: S integer :: i real :: t1 , t2 , d1 print * print * , 'TEST61  : speed test (hash 100 MiB)' allocate ( buffer ( N ) ) do i = 1 , N buffer ( i ) = 97_int8 enddo call cpu_time ( t1 ) call sha3_update ( S , buffer , 224 ) call sha3_digest ( S , digest ) call cpu_time ( t2 ) d1 = t2 - t1 print * , '        ' , sha3_hexdigest ( digest ) print * , 'timings: ' , d1 , 's' deallocate ( buffer ) end subroutine sha3_test61 end subroutine sha3_auto_test","tags":"","loc":"proc/sha3_auto_test.html"},{"title":"sha3_digest – M_hashkeys","text":"public subroutine sha3_digest(state, digest) !GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b‘10000110’,kind=int8),state%buffer(1)) !GFORTRAN 8.3 BUG! !state%buffer( state%r/8 ) = transfer(int(b‘10000000’,kind=int8),state%buffer(1))\n$     do\n$        i = min( r/8, d/8 - j )\n$        sha3_sponge(j+1:j+i) = S(1:i) ! get r bits from state\n$        j = j + i ! update the number of bytes outputted\n$        ! exit when we have enough\n$        if ( j >= d/8 ) exit\n$        ! otherwise, continue squeezing\n$        S = sha3_keccak_p( S, 25 W, 2*ELL+12 )\n$     enddo Arguments Type Intent Optional Attributes Name type( sha3_state ), intent(inout) :: state integer(kind=int8), intent(out), dimension(:) :: digest Contents Variables bug i j string Source Code sha3_digest Variables Type Visibility Attributes Name Initial integer(kind=int8), public :: bug integer, public :: i integer, public :: j integer(kind=int8), public, dimension(25*LANE) :: string Source Code subroutine sha3_digest ( state , digest ) type ( sha3_state ), intent ( inout ) :: state integer ( kind = int8 ), dimension (:), intent ( out ) :: digest integer ( kind = int8 ) :: bug integer :: i , j integer ( kind = int8 ), dimension ( 25 * LANE ) :: string ! it remains to apply padding the the current buffer, add this to sponge ! apply keccak, and squeeze ! the problem may be that, depending on the size of the buffer, we may have ! one or two r-bits blocks after padding digest = 0_int8 ! proceed to padding. in here, we know that bufsize is strictly less than r/8 bytes ! (contrary to the sha3 function) i = mod ( state % bufsize + 1 , state % r / 8 ) ! how many bytes to add if ( i == 0 ) then ! just add one byte for padding, and we have a full block ready to hash !>>>>>>>>>>>> !*!GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b'10000110',kind=int8),state%buffer(1)) bug = setbits8 ( '10000110' ) state % buffer ( state % r / 8 ) = transfer ( bug , state % buffer ( 1 )) !<<<<<<<<<<<< else state % buffer ( state % bufsize + 1 ) = transfer ( int ( b '00000110' , kind = int8 ), state % buffer ( 1 )) state % buffer ( state % bufsize + 2 : state % r / 8 - 1 ) = 0_int8 !>>>>>>>>>>>> !*!GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b'10000000',kind=int8),state%buffer(1)) bug = setbits8 ( '10000000' ) state % buffer ( state % r / 8 ) = transfer ( bug , state % buffer ( 1 )) !<<<<<<<<<<<< endif ! absorb this last block... call sha3_block ( state % S , state % buffer ( 1 : state % r / 8 ), state % r / 8 ) ! ...and squeeze if ( state % d < state % r ) then ! go back from state matrix to string string = sha3_state2string2 ( state % S , 25 * W / 8 ) digest = string ( 1 : state % d / 8 ) do i = 1 , state % d / 8 digest ( i ) = sha3_reverse ( digest ( i )) enddo else j = 0 ! number of bytes currently outputted !!$     do !!$        i = min( r/8, d/8 - j ) !!$        sha3_sponge(j+1:j+i) = S(1:i) ! get r bits from state !!$        j = j + i ! update the number of bytes outputted !!$        ! exit when we have enough !!$        if ( j >= d/8 ) exit !!$        ! otherwise, continue squeezing !!$        S = sha3_keccak_p( S, 25*W, 2*ELL+12 ) !!$     enddo endif ! once the digest has been provide, there are some tasks to perform ! (reinit the state and deallocation) deallocate ( state % buffer ) nullify ( state % buffer ) state % bufsize = - 1 end subroutine sha3_digest","tags":"","loc":"proc/sha3_digest.html"},{"title":"sha3_file – M_hashkeys","text":"public subroutine sha3_file(d, fname, hdigest) Uses M_system Arguments Type Intent Optional Attributes Name integer, intent(in) :: d character(len=*), intent(in) :: fname character(len=*), intent(out), optional :: hdigest Contents Variables S buffer dg digest fexist fsize i j nread nrem values Source Code sha3_file Variables Type Visibility Attributes Name Initial type( sha3_state ), public :: S integer(kind=int8), public, dimension(:), allocatable :: buffer character(len=128), public :: dg integer(kind=int8), public, dimension(d/8) :: digest logical, public :: fexist integer, public :: fsize integer, public :: i integer, public :: j integer, public :: nread integer, public :: nrem integer(kind=int64), public, dimension(13) :: values Source Code subroutine sha3_file ( d , fname , hdigest ) ! hashes a file and either returns the sha3_hexdigest in a string, or display it to ! stdout, along with the file name. d is the digest size in bits (224,256,384,512) use M_system , only : system_stat integer , intent ( in ) :: d character ( len =* ), intent ( in ) :: fname character ( len =* ), optional , intent ( out ) :: hdigest integer ( kind = int8 ), dimension ( d / 8 ) :: digest logical :: fexist integer :: fsize , i , j , nread , nrem type ( sha3_state ) :: S integer ( kind = int8 ), dimension (:), allocatable :: buffer integer ( kind = int64 ), dimension ( 13 ) :: values character ( len = 128 ) :: dg ! does this file exist? if yes, what is its size? inquire ( file = trim ( adjustl ( fname )), exist = fexist ) if ( . not . fexist ) then print * , 'file not found.' return endif call system_stat ( trim ( fname ), values ) fsize = int ( values ( 8 )) ! read the file into a buffer with the appropriate size allocate ( buffer ( 4096 ) ) open ( unit = 39 , file = trim ( adjustl ( fname )), form = 'unformatted' , access = 'direct' , recl = 1 ) nrem = fsize j = 0 do nread = min ( nrem , 4096 ) do i = 1 , nread j = j + 1 read ( 39 , rec = j ) buffer ( i ) enddo if ( nread == 4096 ) then call sha3_update ( S , buffer , d ) else call sha3_update ( S , buffer ( 1 : nread ), d ) endif nrem = nrem - nread if ( nrem <= 0 ) exit enddo close ( 39 ) call sha3_digest ( S , digest ) dg = sha3_hexdigest ( digest ) if ( present ( hdigest ) ) then hdigest = trim ( dg ) else print '(3a)' , trim ( dg ), ' ' , trim ( fname ) endif deallocate ( buffer ) end subroutine sha3_file","tags":"","loc":"proc/sha3_file.html"},{"title":"sha3_update – M_hashkeys","text":"public subroutine sha3_update(state, buffer, d) Arguments Type Intent Optional Attributes Name type( sha3_state ), intent(inout) :: state integer(kind=int8), intent(in), dimension(:) :: buffer integer, intent(in), optional :: d Contents Variables j r8 Source Code sha3_update Variables Type Visibility Attributes Name Initial integer, public :: j integer, public, save :: r8 Source Code subroutine sha3_update ( state , buffer , d ) ! this routine type ( sha3_state ), intent ( inout ) :: state integer ( kind = int8 ), dimension (:), intent ( in ) :: buffer integer , optional , intent ( in ) :: d integer , save :: r8 integer :: j if ( state % bufsize == - 1 ) then ! means we never, ever called sha3_update before, and thus the buffer pointer ! in state is in limbo nullify ( state % buffer ) endif if ( state % bufsize < 0 ) then ! means that we start working on a new input if ( present ( d ) ) then state % d = d else state % d = 224 endif if ( state % d == 224 ) then state % c = 448 elseif ( state % d == 256 ) then state % c = 512 elseif ( state % d == 384 ) then state % c = 768 elseif ( state % d == 512 ) then state % c = 1024 else ! todo endif state % r = 25 * W - state % c ! initialize state state % S = 0_int64 allocate ( state % buffer ( state % r / 4 ) ) state % bufsize = 0 ! buffer allocated, but empty r8 = state % r / 8 endif ! in case there was data left in the *state* buffer from a previous call ! to sha3_update, we append the received data to it if ( state % bufsize > 0 ) then ! complete the state buffer j = min ( size ( buffer ), r8 - state % bufsize ) ! how many bytes from buffer to use state % buffer ( state % bufsize + 1 : state % bufsize + j ) = buffer ( 1 : j ) state % bufsize = state % bufsize + j if ( state % bufsize >= r8 ) then call sha3_block ( state % S , state % buffer ( 1 : r8 ), r8 ) state % bufsize = 0 ! hash the remainder of the data (if any) do if ( j + r8 >= size ( buffer ) ) exit ! hash this block, w call sha3_block ( state % S , buffer ( j + 1 : j + r8 ), r8 ) ! go to next input block j = j + r8 enddo else return endif else ! hash what we can from buffer j = 0 do if ( j + r8 >= size ( buffer ) ) exit ! hash this block, w call sha3_block ( state % S , buffer ( j + 1 : j + r8 ), r8 ) ! go to next input block j = j + r8 enddo endif ! add the remainder to state%buffer: ! just accumulate data, because this cannot be hashed without taking ! padding into account if ( state % bufsize + ( size ( buffer ) - j ) > size ( state % buffer ) ) then print * , 'error, buffer is too small ???' else state % buffer ( state % bufsize + 1 : state % bufsize + size ( buffer ) - j ) = buffer ( j + 1 : size ( buffer ) ) state % bufsize = state % bufsize + size ( buffer ) - j if ( state % bufsize < 0 ) print * , 'error, buffer size < 0' endif ! is buffer large enough to process a block ? if ( state % bufsize >= r8 ) then call sha3_block ( state % S , state % buffer ( 1 : r8 ), r8 ) ! \"resize\" buffer state % buffer ( 1 : state % bufsize - r8 ) = state % buffer ( r8 + 1 : state % bufsize ) state % bufsize = state % bufsize - r8 endif end subroutine sha3_update","tags":"","loc":"proc/sha3_update.html"},{"title":"test_suite_M_sha3 – M_hashkeys","text":"public subroutine test_suite_M_sha3() Uses M_verify M_verify setup\n teardown Arguments None Contents Subroutines test_sha3 test_sha3_auto_test test_sha3_digest test_sha3_file test_sha3_hexdigest test_sha3_update Source Code test_suite_M_sha3 Subroutines subroutine test_sha3() call unit_check(‘sha3’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_sha3_auto_test() call unit_check(‘sha3_auto_test’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_sha3_digest() call unit_check(‘sha3_digest’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_sha3_file() call unit_check(‘sha3_file’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_sha3_hexdigest() call unit_check(‘sha3_hexdigest’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_sha3_update() call unit_check(‘sha3_update’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_suite_M_sha3 () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level !! setup call test_sha3 () call test_sha3_auto_test () call test_sha3_digest () call test_sha3_file () call test_sha3_hexdigest () call test_sha3_update () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3 () call unit_check_start ( 'sha3' , msg = '' ) !!call unit_check('sha3', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3' , msg = '' ) end subroutine test_sha3 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_auto_test () call unit_check_start ( 'sha3_auto_test' , msg = '' ) !!call unit_check('sha3_auto_test', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_auto_test' , msg = '' ) end subroutine test_sha3_auto_test !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_digest () call unit_check_start ( 'sha3_digest' , msg = '' ) !!call unit_check('sha3_digest', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_digest' , msg = '' ) end subroutine test_sha3_digest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_file () call unit_check_start ( 'sha3_file' , msg = '' ) !!call unit_check('sha3_file', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_file' , msg = '' ) end subroutine test_sha3_file !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_hexdigest () call unit_check_start ( 'sha3_hexdigest' , msg = '' ) !!call unit_check('sha3_hexdigest', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_hexdigest' , msg = '' ) end subroutine test_sha3_hexdigest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sha3_update () call unit_check_start ( 'sha3_update' , msg = '' ) !!call unit_check('sha3_update', 0.eq.0, 'checking',100) call unit_check_done ( 'sha3_update' , msg = '' ) end subroutine test_sha3_update !=================================================================================================================================== end subroutine test_suite_M_sha3","tags":"","loc":"proc/test_suite_m_sha3.html"},{"title":"b3hs_hash_key_jenkins – M_hashkeys","text":"public function b3hs_hash_key_jenkins(key, range) result(code) NAME b3hs_hash_key_jenkins(3f) - [M_hashkeys] hash key algorithm by Bob Jenkins\n   (LICENSE:PD) SYNOPSIS function b3hs_hash_key_jenkins (key, range) result (code) character(*), intent(in) :: key\ninteger, intent(in)      :: range\ninteger                  :: code DESCRIPTION Based on implementation of Bob Jenkins hash function by Rich Townsen,\n   posted 2008-03-23 at http://computer-programming-forum.com/49-fortran/0596e59d0fa2e5e4.htm OPTIONS KEY    string to generate a hash key for\n   RANGE  range should be a power of 2. Note that the 32-bit algorithm is used RETURNS CODE   returned hash value in range specified by RANGE Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(in) :: range Return Value integer Contents Variables a b c k len_key Subroutines b3hs_hash_key_jenkins_mix_ Source Code b3hs_hash_key_jenkins Variables Type Visibility Attributes Name Initial integer(kind=int32), public :: a integer(kind=int32), public :: b integer(kind=int32), public :: c integer, public :: k integer, public :: len_key Subroutines subroutine b3hs_hash_key_jenkins_mix_() Arguments None Source Code function b3hs_hash_key_jenkins ( key , range ) result ( code ) character ( * ), intent ( in ) :: key integer , intent ( in ) :: range integer :: code integer :: len_key integer ( int32 ) :: a integer ( int32 ) :: b integer ( int32 ) :: c integer :: k ! Hash the key into a code, using the algorithm described by Bob Jenkins at: !  http://burtleburtle.net/bob/hash/doobs.html ! ! Note that range should be a power of 2, and that the 32-bit algorithm is used len_key = LEN_TRIM ( key ) a = - 1640531527_int32 ! 0x9E3779B9 b = a c = 305419896_int32 ! 0x12345678 k = 1 char_loop : do if ( len_key < 12 ) exit char_loop ! Pack the key into 32 bits a = a + ICHAR ( key ( k + 0 : k + 0 )) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) c = c + ICHAR ( key ( k + 8 : k + 8 )) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 8 ) + & & ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 16 ) + ISHFT ( ICHAR ( key ( k + 11 : k + 11 )), 24 ) ! Mix it up call b3hs_hash_key_jenkins_mix_ () k = k + 12 len_key = len_key - 12 end do char_loop c = c + len_key ! Process remaining bits select case ( len_key ) case ( 11 ) c = c + ISHFT ( ICHAR ( key ( k + 10 : k + 10 )), 24 ) + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 10 ) c = c + ISHFT ( ICHAR ( key ( k + 9 : k + 9 )), 16 ) + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 9 ) c = c + ISHFT ( ICHAR ( key ( k + 8 : k + 8 )), 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 8 ) b = b + ISHFT ( ICHAR ( key ( k + 7 : k + 7 )), 24 ) + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 7 ) b = b + ISHFT ( ICHAR ( key ( k + 6 : k + 6 )), 16 ) + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + & & ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 6 ) b = b + ISHFT ( ICHAR ( key ( k + 5 : k + 5 )), 8 ) + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 5 ) b = b + ICHAR ( key ( k + 4 : k + 4 )) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 4 ) a = a + ISHFT ( ICHAR ( key ( k + 3 : k + 3 )), 24 ) + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + & & ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 3 ) a = a + ISHFT ( ICHAR ( key ( k + 2 : k + 2 )), 16 ) + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + & & ICHAR ( key ( k : k )) case ( 2 ) a = a + ISHFT ( ICHAR ( key ( k + 1 : k + 1 )), 8 ) + ICHAR ( key ( k : k )) case ( 1 ) a = a + ICHAR ( key ( k : k )) end select call b3hs_hash_key_jenkins_mix_ () code = IAND ( c , range - 1 ) + 1 ! Finish contains subroutine b3hs_hash_key_jenkins_mix_ ! Mix a, b and c a = IEOR ( a - b - c , ISHFT ( c , - 13 )) b = IEOR ( b - c - a , ISHFT ( a , 8 )) c = IEOR ( c - a - b , ISHFT ( b , - 13 )) a = IEOR ( a - b - c , ISHFT ( c , - 12 )) b = IEOR ( b - c - a , ISHFT ( a , 16 )) c = IEOR ( c - a - b , ISHFT ( b , - 5 )) a = IEOR ( a - b - c , ISHFT ( c , - 3 )) b = IEOR ( b - c - a , ISHFT ( a , 10 )) c = IEOR ( c - a - b , ISHFT ( b , - 15 )) ! Finish end subroutine b3hs_hash_key_jenkins_mix_ end function b3hs_hash_key_jenkins","tags":"","loc":"proc/b3hs_hash_key_jenkins.html"},{"title":"dirty_sha256 – M_hashkeys","text":"public function dirty_sha256(str) NAME dirtys_sha256 ( 3 f ) - [ M_hashkeys ] generate a SHA - 256 hashing SYNOPSIS function dirtys_sha256(str) character(len=64)            :: dirtys_sha256\ncharacter(len=*), intent(in) :: str DESCRIPTION A Fortran module for SHA - 256 hashing . The quick and dirty routine ( dirtys_sha256 ( 3 f )) operates on whatever bits that come in , without swapping to big - endian words , and does therefore not pass any of the standard tests - but works at roughly twice the speed . Use this if you want a good hash function but don ' t care about following the SHA - 256 standard specifications . Note that this code will not produce the same results on big - endian machines and the module was only tested on a little - endian Ubuntu LTS 12 . 04 system using gfortran 4 . 6 . 3 and CygWin using Gortran 7 . 3 . 0 . OPTIONS str      The message to digest. RETURNS dirtys_sha256   The SHA-256 digest as a string of length 64. AUTHOR This routine is heavily based on the SHA - 256 routines by Mikael Leetmaa < leetmaa @kth . se > , 2014 - 01 - 05. changes have been made to incorporate it into the GPF ( General Purpose Fortran ) framework . If you found this useful , please let Mikael Leetmaa know . EXAMPLES Using slurp ( 3 f ) and switch ( 3 f ) from the GPF ( General Purpose Fortran ) collection to read in a file and convert it into a string , generate digest values for a list of files . Note that this example reads the entire input file into memory twice , and so requires very large amounts of memory if very large files are processed . program demo_dirty_sha256 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_hashkeys , only : sha256 , dirty_sha256 use M_io , only : slurp use M_strings , only : switch implicit none character ( len = 1 ), allocatable :: text (:) ! array to hold file in memory character ( len = :), allocatable :: string integer :: i character ( len = 4096 ) :: filename do i = 1 , command_argument_count () ! step through filenames on command line call get_command_argument ( i , filename ) call slurp ( filename , text ) ! allocate character array and copy file into it if ( . not . allocated ( text )) then write ( ERROR_UNIT , * ) '*rever* ERROR: failed to load file ' // trim ( filename ) else string = switch ( text ) ! switch array to a single character variable deallocate ( text ) ! release memory write ( * , * ) dirty_sha256 ( string ), len ( string ), trim ( filename ) ! write digest value endif enddo end program demo_dirty_sha256 Sample output: FA9D11011034F1081A367D4F2F1EB909AC0849FF090A9320B6824156C5628DFD        2011 dynamic_dummy_arrays.f90\n FE48473BC7B9C13067EC2C108CB8A650A186605D5F905736D9CB9DE76E9A1A21        5444 fspiro.f90\n 306CDB5BB2A8C30C711FA5D35A6A12F4FDB4F003ED77438E922B56BBA1024F49       27108 pprint.f90 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=64) Contents Source Code dirty_sha256 Source Code function dirty_sha256 ( str ) implicit none ! ident_2=\"@(#)M_hashkeys::dirty_sha256(3f): Quick and dirty SHA-256 interface function (no bit-swapping).\" ! Define the interface. character ( len = 64 ) :: dirty_sha256 ! The SHA-256 digest as a string of length 64. character ( len =* ), intent ( in ) :: str ! The message to digest. ! Call the work horse - no bit swapping. dirty_sha256 = sha256b ( str , 0 ) end function dirty_sha256","tags":"","loc":"proc/dirty_sha256.html"},{"title":"djb2 – M_hashkeys","text":"public function djb2(anything) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value integer(kind=int128) Contents Variables chars Interfaces djb2_F Source Code djb2 Variables Type Visibility Attributes Name Initial character(len=1), public, allocatable :: chars (:) Interfaces interface function djb2_F(S) bind(C,NAME='C_djb2') Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in) :: S (*) Return Value integer(kind=C_LONG) Source Code function djb2 ( anything ) implicit none ! ident_10=\"@(#)djb2(3f): call C routine djb2(3c) with a Fortran CHARACTER variable\" ! extern int djb2(char *s); interface function djb2_F ( S ) bind ( C , NAME = 'C_djb2' ) use ISO_C_BINDING , only : C_LONG , C_CHAR implicit none integer ( KIND = C_LONG ) :: djb2_F character ( KIND = C_CHAR ), intent ( in ) :: S ( * ) end function djb2_F end interface class ( * ), intent ( in ) :: anything (:) integer ( kind = int128 ) :: djb2 character ( len = 1 ), allocatable :: chars (:) chars = anything_to_bytes ( anything ) djb2 = transfer ([ djb2_F ([ chars , char ( 0 )]), 0_int64 ], djb2 ) if ( debug ) then DEBUG : block integer :: i integer :: ios write ( 6 , '(\"*djb2 FORTRAN*        hashing string=\",*(a))' , advance = 'no' )( chars ( i ), i = 1 , size ( chars )) write ( 6 , '(1x,\"hash=\",i0,1x,\"hex hash=\",z32.32)' ) djb2 , djb2 flush ( 6 , iostat = ios ) endblock DEBUG endif end function djb2","tags":"","loc":"proc/djb2.html"},{"title":"luhn_checksum – M_hashkeys","text":"public function luhn_checksum(string) Uses M_strings NAME luhn_checksum ( 3 f ) - [ M_hashkeys ] Luhn checksum algorithm applied to a string of numeric values DESCRIPTION The Luhn algorithm or Luhn formula , also known as the \"modulus 10\" or \"mod 10\" algorithm , named after IBM scientist Hans Peter Luhn , is a simple checksum formula used to validate a variety of identification numbers such as credit card numbers , IMEI numbers , National Provider Identifier numbers in the United States , Canadian Social Insurance Numbers , Israel ID Numbers , Greek Social Security Numbers , and survey codes appearing on McDonald 's, Taco Bell, and Tractor Supply Co. receipts. It was created by IBM scientist Hans Peter Luhn and described in U . S . Patent No . 2 , 950 , 048 , filed on January 6 , 1954 , and granted on August 23 , 1960. The algorithm is in the public domain and is in wide use today . It is specified in ISO / IEC 7812 - 1. [ 1 ] It is not intended to be a cryptographically secure hash function ; it was designed to protect against accidental errors , not malicious attacks . Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from mistyped or otherwise incorrect numbers . The formula verifies a number against its included check digit , which is usually appended to a partial account number to generate the full account number . This number must pass the following test : 1. From the rightmost digit , which is the check digit , and moving left , double the value of every second digit . The check digit is not doubled ; the first digit doubled is immediately to the left of the check digit . If the result of this doubling operation is greater than 9 ( e . g . , 8 × 2 = 16 ), then add the digits of the result ( e . g . , 16 : 1 + 6 = 7 , 18 : 1 + 8 = 9 ) or , alternatively , the same final result can be found by subtracting 9 from that result ( e . g . , 16 : 16 − 9 = 7 , 18 : 18 − 9 = 9 ) . 2. Take the sum of all the digits . 3. If the total modulo 10 is equal to 0 ( if the total ends in zero ) then the number is valid according to the Luhn formula ; else it is not valid . Assume an example of an account number \"7992739871\" that will have a check digit added , making it of the form 7992739871 x : Account number 7 9 9 2 7 3 9 8 7 1 x Double every other 7 18 9 4 7 6 9 16 7 2 x Sum digits 7 9 9 4 7 6 9 7 7 2 x The sum of all the digits in the third row is 67 + x . The check digit ( x ) is obtained by computing the sum of the non - check digits then computing 9 times that value modulo 10 ( in equation form , (( 67 × 9 ) mod 10 )) . In algorithm form : 1. Compute the sum of the non - check digits ( 67 ) . 2. Multiply by 9 ( 603 ) . 3. The units digit ( 3 ) is the check digit . Thus , x = 3. ( Alternative method ) The check digit ( x ) is obtained by computing the sum of the other digits ( third row ) then subtracting the units digit from 10 ( 67 => Units digit 7 ; 10 − 7 = check digit 3 ) . In algorithm form : 1. Compute the sum of the non - check digits ( 67 ) . 2. Take the units digit ( 7 ) . 3. Subtract the units digit from 10. 4. The result ( 3 ) is the check digit . In case the sum of digits ends in 0 then 0 is the check digit . This makes the full account number read 79927398713. Each of the numbers 79927398710 , 79927398711 , 79927398712 , 79927398713 , 79927398714 , 79927398715 , 79927398716 , 79927398717 , 79927398718 , 79927398719 can be validated as follows . 1. Double every second digit , from the rightmost : ( 1 × 2 ) = 2 , ( 8 × 2 ) = 16 , ( 3 × 2 ) = 6 , ( 2 × 2 ) = 4 , ( 9 × 2 ) = 18 2. Sum all the individual digits ( digits in parentheses are the products from Step 1 ): x ( the check digit ) + ( 2 ) + 7 + ( 1 + 6 ) + 9 + ( 6 ) + 7 + ( 4 ) + 9 + ( 1 + 8 ) + 7 = x + 67. 3. If the sum is a multiple of 10 , the account number is possibly valid . Note that 3 is the only valid digit that produces a sum ( 70 ) that is a multiple of 10. 4. Thus these account numbers are all invalid except possibly 79927398713 which has the correct check digit . Alternately , you can use the same checksum creation algorithm , ignoring the checksum already in place as if it had not yet been calculated . Then calculate the checksum and compare this calculated checksum to the original checksum included with the credit card number . If the included checksum matches the calculated checksum , then the number is valid . STRENGTHS AND WEAKNESSES The Luhn algorithm will detect any single - digit error , as well as almost all transpositions of adjacent digits . It will not , however , detect transposition of the two - digit sequence 09 to 90 ( or vice versa ) . It will detect 7 of the 10 possible twin errors ( it will not detect 22 ↔ 55 , 33 ↔ 66 or 44 ↔ 77 ) . Other , more complex check - digit algorithms ( such as the Verhoeff algorithm and the Damm algorithm ) can detect more transcription errors . The Luhn mod N algorithm is an extension that supports non - numerical strings . Because the algorithm operates on the digits in a right - to - left manner and zero digits affect the result only if they cause shift in position , zero - padding the beginning of a string of numbers does not affect the calculation . Therefore , systems that pad to a specific number of digits ( by converting 1234 to 0001234 for instance ) can perform Luhn validation before or after the padding and achieve the same result . Prepending a 0 to odd - length numbers makes it possible to process the number from left to right rather than right to left , doubling the odd - place digits . The algorithm appeared in a US Patent [ 2 ] for a hand - held , mechanical device for computing the checksum . It was therefore required to be rather simple . The device took the mod 10 sum by mechanical means . The substitution digits , that is , the results of the double and reduce procedure , were not produced mechanically . Rather , the digits were marked in their permuted order on the body of the machine . OPTIONS S                 the string of digits to be checked. Spaces and dashes\n                    are ignored. RESULT LUHN_CHECKSUM     the Luhn checksum of the string; which is the digits in the\n                    input string with the checksum digit appended. REFERENCES From Wikipedia, the free encyclopedia\n\n    (https://en.wikipedia.org/wiki/Luhn_algorithm) EXAMPLES Sample program program demo_luhn_checksum use M_hashkeys , only : luhn_checksum implicit none character ( len = : ) , allocatable :: ccards ( : ) , string integer :: i , j write ( * , * ) ' GOOD VALUES ' ccards = [ character ( len = 20 ) :: ' 79927398713 ' , & & ' 49927398716 ' , & & ' 1234567812345670 ' ] call checkem () write ( * , * ) ' BAD VALUES ' ccards = [ character ( len = 20 ) :: & & ' 79927398710 ' , ' 79927398711 ' , ' 79927398712 ' , ' 79927398714 ' , & & ' 79927398715 ' , ' 79927398716 ' , ' 79927398717 ' , ' 79927398718 ' , & & ' 79927398719 ' , & ' 49927398717 ' , ' 1234567812345678 ' ] call checkem () contains subroutine checkem ! validate these numbers do i = 1 , size ( ccards ) j = len ( trim ( ccards ( i ))) string = luhn_checksum ( ccards ( i )( : j - 1 )) write ( * , ' (a,1x,a,1x,l1) ' ) ccards ( i ) , string , ccards ( i ) . eq . string enddo string = ' 123456 781-234-567 ' write ( * , * ) ' from ' , string , ' got ' , luhn_checksum ( string ) , & & ' which should be 1234567812345670 ' end subroutine checkem end program demo_luhn_checksum Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable Contents Variables d2 dgts i ios n string_local value Source Code luhn_checksum Variables Type Visibility Attributes Name Initial integer, public :: d2 integer, public, allocatable :: dgts (:) integer, public :: i integer, public :: ios integer, public :: n character(len=:), public, allocatable :: string_local integer, public :: value Source Code function luhn_checksum ( string ) use M_strings , only : transliterate ! ident_3=\"@(#)LUHN_CHECKSUM determines the Luhn checksum of a string composed of digits\" character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: luhn_checksum , string_local integer , allocatable :: dgts (:) integer :: n integer :: i integer :: value integer :: d2 integer :: ios string_local = transliterate ( string , ' -' , '' ) ! delete spaces and dashes n = len ( trim ( string_local )) ! Count the digits in string_local assuming the string_local is all digits. allocate ( dgts ( n )) read ( string_local , '(*(i1))' , iostat = ios )( dgts ( i ), i = 1 , n ) ! Extract the digits from S. if ( ios . ne . 0 ) then stop '*luhn_checksum* error reading digits' endif value = 0 do i = n , 1 , - 2 ! starting from the right double every other value and subtract 9 if the value is .gt. 9 and sum them d2 = dgts ( i ) * 2 value = value + merge ( d2 - 9 , d2 , d2 . gt . 9 ) enddo do i = n - 1 , 1 , - 2 ! add in the other values value = value + dgts ( i ) enddo value = mod ( value * 9 , 10 ) allocate ( character ( len = n + 1 ) :: luhn_checksum ) write ( luhn_checksum , '(a,i1)' ) string_local (: n ), value end function luhn_checksum","tags":"","loc":"proc/luhn_checksum.html"},{"title":"sha256 – M_hashkeys","text":"public function sha256(str) For the sha256 and dirty_sha256 procedures and supporting private routines : Copyright ( c ) 2014 Mikael Leetmaa This software is provided 'as-is' , without any express or implied warranty . In no event will the authors be held liable for any damages arising from the use of this software . Permission is granted to anyone to use this software for any purpose , including commercial applications , and to alter it and redistribute it freely , subject to the following restrictions : 1 . The origin of this software must not be misrepresented ; you must not claim that you wrote the original software . If you use this software in a product , an acknowledgment in the product documentation would be appreciated but is not required . 2 . Altered source versions must be plainly marked as such , and must not be misrepresented as being the original software . 3 . This notice may not be removed or altered from any source distribution . NAME sha256 ( 3 f ) - [ M_hashkeys ] generate a SHA - 256 hashing SYNOPSIS function sha256(str) character(len=64)            :: sha256\ncharacter(len=*), intent(in) :: str DESCRIPTION A Fortran module for SHA - 256 hashing . Note that this code will not produce the same results on big - endian machines and the module was only tested on a little - endian Ubuntu LTS 12 . 04 system using gfortran 4 . 6 . 3 . OPTIONS str      The message to digest. RETURNS sha256   The SHA-256 digest as a string of length 64. COMPILE NOTES The ' -fno-range-check ' flag is required on gfortran ( 1 ) since the Fortran standard otherwise doesn ' t currently allow us to work with all bits in the integers ( as if they were unsigned ) . AUTHOR This routine is heavily based on the SHA - 256 routines by Mikael Leetmaa < leetmaa @kth . se > , 2014 - 01 - 05. changes have been made to incorporate it into the GPF ( General Purpose Fortran ) framework . If you found this useful , please let Mikael Leetmaa know . EXAMPLE Sample program: program demo_sha256 use M_hashkeys , only : sha256 , dirty_sha256 implicit none character ( len = : ) , allocatable :: str character ( len = 64 ) :: ref ! Test the sha256 function with a set of reference strings . str = \"\" ref = \" E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 1 ' ) str = \" abc \" ref = \" BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 2 ' ) str = \" abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq \" ref = \" 248D6A61D20638B8E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 3 ' ) str = \" abcdefghbcdefghicdefghijdefghijkefghijklfghi& & jklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu \" ref = \" CF5B16A778AF8380036CE59E7B0492370B249B11E8F07A51AFAC45037AFEE9D1 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 4 ' ) str = repeat ( \" a \" , 1000000 ) ref = \" CDC76E5C9914FB9281A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 5 ' ) str = \" message digest \" ref = \" F7846F55CF23E14EEBEAB5B4E1550CAD5B509E3348FBC4EFA3A1413D393CB650 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 6 ' ) str = \" secure hash algorithm \" ref = \" F30CEB2BB2829E79E4CA9753D35A8ECC00262D164CC077080295381CBD643F0D \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 7 ' ) str = \" SHA256 is considered to be safe \" ref = \" 6819D915C73F4D1E77E4E1B52D1FA0F9CF9BEAEAD3939F15874BD988E2A23630 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 8 ' ) str = \" For this sample, this 63-byte string will be used as input data \" ref = \" F08A78CBBAEE082B052AE0708F32FA1E50C5C421AA772BA5DBB406A2EA6BE342 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 9 ' ) str = \" This is exactly 64 bytes long, not counting the terminating byte \" ref = \" AB64EFF7E88E2E46165E29F2BCE41826BD4C7B3552F6B382A9E7D3AF47C245F8 \" call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 10 ' ) ! Check the quick and dirty implementation as well . ref = \" 69E3FACD5F08321F78117BD53476E5321845433356F106E7013E68EC367F3017 \" call unit_check ( ' sha256 ' , dirty_sha256 ( str ) == ref , ' test dirtysha256 1 ' ) !! str = repeat ( \" abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno \" , 16777216 ) !! ref = \" 50E72A0E26442FE2552DC3938AC58658228C0CBFB1D2CA872AE435266FCD055E \" !! call unit_check ( ' sha256 ' , sha256 ( str ) == ref , ' test sha256 11 -- long test ' ) contains subroutine unit_check ( name , test , message ) character ( len =* ) , intent ( in ) :: name logical , intent ( in ) :: test character ( len =* ) , intent ( in ) :: message write ( * , ' (a) ' ) repeat ( \" = \" , 64 ) write ( * , ' (a) ' ) sha256 ( str ) write ( * , ' (a) ' ) ref if ( test ) then write ( * , * ) trim ( name ) , \" PASSED: \" , trim ( message ) else write ( * , * ) trim ( name ) , \" FAILED: \" , trim ( message ) endif end subroutine unit_check ! end program demo_sha256 UNIT TEST When porting to a new programming environment use the\n   built-in unit test … program test_sha256 use M_hashkeys , only : test_suite_sha256 call test_suite_sha256 () end program test_sha256 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=64) Contents Source Code sha256 Source Code function sha256 ( str ) implicit none ! ident_1=\"@(#)M_hashkeys::sha256(3f): SHA-256 interface function\" ! Define the interface. character ( len = 64 ) :: sha256 ! The SHA-256 digest as a string of length 64. character ( len =* ), intent ( in ) :: str ! (in) The message to digest. ! Call the work horse with proper bit swapping. sha256 = sha256b ( str , 1 ) end function sha256","tags":"","loc":"proc/sha256.html"},{"title":"test_suite_M_hashkeys – M_hashkeys","text":"public subroutine test_suite_M_hashkeys() Arguments None Contents Source Code test_suite_M_hashkeys Source Code subroutine test_suite_M_hashkeys call test_luhn_checksum () end subroutine test_suite_M_hashkeys","tags":"","loc":"proc/test_suite_m_hashkeys.html"},{"title":"test_suite_sha256 – M_hashkeys","text":"public subroutine test_suite_sha256() Uses M_verify M_verify Arguments None Contents Variables a_bin a_bin_flip abc_bin abc_bin_flip abc_bin_ref abc_bin_swap abca_bin abca_bin_flip bcab_bin bcab_bin_flip big_endian_464 ca_one_zero ca_one_zero_flip cabc_bin cabc_bin_flip empty_bin empty_str_bin empty_str_bin_flip ipad1 ipad2 ipad3 ipad4 ipad5 ipad6 little_endian_464 shft5_l11 shft5_r8 shftc4_l12 shftc4_r2 Subroutines pad_message1 pad_message2 test_ch test_cs0 test_cs1 test_ishft test_ishftc test_maj test_ms0 test_ms1 test_sha256_1 test_sha256_11 test_sha256_5 test_sha256_6 test_swap32 Source Code test_suite_sha256 Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: a_bin = int(b'00000000000000000000000101100001', kind=int32) integer(kind=int32), public, parameter :: a_bin_flip = int(b'01100001100000000000000000000000', kind=int32) integer(kind=int32), public, parameter :: abc_bin = int(b'00000001011000110110001001100001', kind=int32) integer(kind=int32), public, parameter :: abc_bin_flip = int(b'01100001011000100110001110000000', kind=int32) integer(kind=int32), public, parameter :: abc_bin_ref = int(b'00000001011000110110001001100001', kind=int32) integer(kind=int32), public, parameter :: abc_bin_swap = int(b'01100001011000100110001100000001', kind=int32) integer(kind=int32), public, parameter :: abca_bin = int(b'01100001011000110110001001100001', kind=int32) integer(kind=int32), public, parameter :: abca_bin_flip = int(b'01100001011000100110001101100001', kind=int32) integer(kind=int32), public, parameter :: bcab_bin = int(b'01100010011000010110001101100010', kind=int32) integer(kind=int32), public, parameter :: bcab_bin_flip = int(b'01100010011000110110000101100010', kind=int32) integer(kind=int32), public, parameter :: big_endian_464 = ibset(int(ibclr(int(b'11010000000000010000000000000000', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ca_one_zero = int(b'00000000000000010110000101100011', kind=int32) integer(kind=int32), public, parameter :: ca_one_zero_flip = int(b'01100011011000011000000000000000', kind=int32) integer(kind=int32), public, parameter :: cabc_bin = int(b'01100011011000100110000101100011', kind=int32) integer(kind=int32), public, parameter :: cabc_bin_flip = int(b'01100011011000010110001001100011', kind=int32) integer(kind=int32), public, parameter :: empty_bin = int(b'00000000000000000000000000000000', kind=int32) integer(kind=int32), public, parameter :: empty_str_bin = int(b'00000000000000000000000000000001', kind=int32) integer(kind=int32), public, parameter :: empty_str_bin_flip = ibset(int(ibclr(int(b'10000000000000000000000000000000', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ipad1 = int(b'00000000000000000000000000000011', kind=int32) integer(kind=int32), public, parameter :: ipad2 = ibset(int(ibclr(int(b'11111111111111111111111111111111', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ipad3 = ibset(int(ibclr(int(b'10010000101001110011001110010011', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ipad4 = ibset(int(ibclr(int(b'11001001101001110011001110010011', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ipad5 = ibset(int(ibclr(int(b'10000001101001010011000110100001', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: ipad6 = ibset(int(ibclr(int(b'11000000000000000000000000000000', kind=int64), 31), kind=int32), 31) integer(kind=int32), public, parameter :: little_endian_464 = int(b'00000000000000000000000111010000', kind=int32) integer(kind=int32), public, parameter :: shft5_l11 = int(b'00101001100011010000100000000000', kind=int32) integer(kind=int32), public, parameter :: shft5_r8 = int(b'00000000100000011010010100110001', kind=int32) integer(kind=int32), public, parameter :: shftc4_l12 = int(b'01110011001110010011110010011010', kind=int32) integer(kind=int32), public, parameter :: shftc4_r2 = ibset(int(ibclr(int(b'11110010011010011100110011100100', kind=int64), 31), kind=int32), 31) Subroutines subroutine pad_message1() Arguments None subroutine pad_message2() Arguments None subroutine test_ch() Arguments None subroutine test_cs0() Arguments None subroutine test_cs1() Arguments None subroutine test_ishft() Arguments None subroutine test_ishftc() Arguments None subroutine test_maj() Arguments None subroutine test_ms0() Arguments None subroutine test_ms1() Arguments None subroutine test_sha256_1() Arguments None subroutine test_sha256_11() Arguments None subroutine test_sha256_5() Arguments None subroutine test_sha256_6() Arguments None subroutine test_swap32() Arguments None Source Code subroutine test_suite_sha256 () use M_verify , only : unit_check , unit_check_start , unit_check_done use M_verify , only : unit_check_level implicit none integer ( kind = int32 ), parameter :: ipad1 = int ( b '00000000000000000000000000000011' , kind = int32 ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> integer ( kind = int32 ), parameter :: ipad2 = ibset ( int ( ibclr ( int ( b '11111111111111111111111111111111' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad3 = ibset ( int ( ibclr ( int ( b '10010000101001110011001110010011' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad4 = ibset ( int ( ibclr ( int ( b '11001001101001110011001110010011' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad5 = ibset ( int ( ibclr ( int ( b '10000001101001010011000110100001' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: ipad6 = ibset ( int ( ibclr ( int ( b '11000000000000000000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: shftc4_r2 = ibset ( int ( ibclr ( int ( b '11110010011010011100110011100100' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: empty_str_bin_flip & & = ibset ( int ( ibclr ( int ( b '10000000000000000000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) integer ( kind = int32 ), parameter :: big_endian_464 & & = ibset ( int ( ibclr ( int ( b '11010000000000010000000000000000' , kind = int64 ), 31 ), kind = int32 ), 31 ) !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> integer ( kind = int32 ), parameter :: shftc4_l12 = int ( b '01110011001110010011110010011010' , kind = int32 ) integer ( kind = int32 ), parameter :: shft5_r8 = int ( b '00000000100000011010010100110001' , kind = int32 ) integer ( kind = int32 ), parameter :: shft5_l11 = int ( b '00101001100011010000100000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin = int ( b '00000001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: a_bin = int ( b '00000000000000000000000101100001' , kind = int32 ) integer ( kind = int32 ), parameter :: empty_str_bin = int ( b '00000000000000000000000000000001' , kind = int32 ) integer ( kind = int32 ), parameter :: empty_bin = int ( b '00000000000000000000000000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_flip = int ( b '01100001011000100110001110000000' , kind = int32 ) integer ( kind = int32 ), parameter :: a_bin_flip = int ( b '01100001100000000000000000000000' , kind = int32 ) integer ( kind = int32 ), parameter :: abca_bin = int ( b '01100001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: bcab_bin = int ( b '01100010011000010110001101100010' , kind = int32 ) integer ( kind = int32 ), parameter :: cabc_bin = int ( b '01100011011000100110000101100011' , kind = int32 ) integer ( kind = int32 ), parameter :: ca_one_zero = int ( b '00000000000000010110000101100011' , kind = int32 ) integer ( kind = int32 ), parameter :: little_endian_464 = int ( b '00000000000000000000000111010000' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_ref = int ( b '00000001011000110110001001100001' , kind = int32 ) integer ( kind = int32 ), parameter :: abc_bin_swap = int ( b '01100001011000100110001100000001' , kind = int32 ) integer ( kind = int32 ), parameter :: abca_bin_flip = int ( b '01100001011000100110001101100001' , kind = int32 ) integer ( kind = int32 ), parameter :: bcab_bin_flip = int ( b '01100010011000110110000101100010' , kind = int32 ) integer ( kind = int32 ), parameter :: cabc_bin_flip = int ( b '01100011011000010110001001100011' , kind = int32 ) integer ( kind = int32 ), parameter :: ca_one_zero_flip = int ( b '01100011011000011000000000000000' , kind = int32 ) call test_swap32 call test_ishftc call test_ishft call pad_message1 call pad_message2 call test_ch call test_maj call test_cs0 call test_cs1 call test_ms0 call test_ms1 call test_sha256_1 call test_sha256_5 call test_sha256_6 call test_sha256_11 contains ! Test the swap function. subroutine test_swap32 call unit_check_start ( 'swap32' ) call unit_check ( 'swap32' , swap32 ( abc_bin ) == abc_bin_swap , 'test swap32 function' ) call unit_check ( 'swap32' , abc_bin == abc_bin_ref , 'test swap value' ) call unit_check_done ( 'swap32' ) end subroutine test_swap32 subroutine test_ishftc ! Make sure the intrinsic ishftc function does what we think. integer ( kind = int32 ) :: a call unit_check_start ( 'ishftc' ) a = ishftc ( ipad4 , - 2 ) call unit_check ( 'ishftc' , a == shftc4_r2 , 'verify ishftc A' ) a = ishftc ( ipad4 , 12 ) call unit_check ( 'ishftc' , a == shftc4_l12 , 'verify ishftc B' ) call unit_check_done ( 'ishftc' ) end subroutine test_ishftc ! Make sure the intrinsic ishft function does what we think. subroutine test_ishft integer ( kind = int32 ) :: a call unit_check_start ( 'ishft' ) a = ishft ( ipad5 , - 8 ) call unit_check ( 'ishft' , a == shft5_r8 , 'verify ishft A' ) a = ishft ( ipad5 , 11 ) call unit_check ( 'ishft' , a == shft5_l11 , 'verify ishft B' ) call unit_check_done ( 'ishft' ) end subroutine test_ishft ! Test the message padding. subroutine pad_message1 character ( len = 1000 ) :: str integer ( kind = int32 ) :: inp ( 16 ) integer ( kind = 8 ) :: length integer :: pos0 , break integer :: swap = 1 call unit_check_start ( 'pad_message1' ) ! Set the message to \"\". str = \"\" pos0 = 1 break = 0 length = 0 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == empty_str_bin_flip , 'message padding A' ) ! Set the message to \"abc\". str = \"abc\" pos0 = 1 break = 0 length = 3 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == abc_bin_flip , 'message padding B' ) ! Set the message to \"a\". str = \"a\" pos0 = 1 break = 0 length = 1 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the first word. call unit_check ( 'pad_message1' , inp ( 1 ) == a_bin_flip , 'message padding C' ) call unit_check_done ( 'pad_message1' ) end subroutine pad_message1 ! Test the message padding. subroutine pad_message2 character ( len = 1024 ) :: str integer ( kind = int32 ) :: inp ( 16 ) integer ( kind = 8 ) :: length integer :: pos0 , break integer :: swap = 1 ! Set the message. str = \"abcabcabcabcabcaabcabcabcabcabcaabcabcabcabcabcaabcabcabca\" pos0 = 1 break = 0 length = 58 call consume_chunk ( str , length , inp , pos0 , break , swap ) ! Check the whole message. call unit_check_start ( 'pad_message2' ) call unit_check ( 'pad_message2' , inp ( 1 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 2 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 3 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 4 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 5 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 6 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 7 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 8 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 9 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 10 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 11 ) == cabc_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 12 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 13 ) == abca_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 14 ) == bcab_bin_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 15 ) == ca_one_zero_flip , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 16 ) == empty_bin , 'message padding 2' ) call consume_chunk ( str , length , inp , pos0 , break , swap ) call unit_check ( 'pad_message2' , inp ( 1 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 2 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 3 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 4 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 5 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 6 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 7 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 8 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 9 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 10 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 11 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 12 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 13 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 14 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 15 ) == empty_bin , 'message padding 2' ) call unit_check ( 'pad_message2' , inp ( 16 ) == little_endian_464 , 'message padding 2' ) call unit_check_done ( 'pad_message2' ) end subroutine pad_message2 ! Test the ch function. subroutine test_ch integer ( kind = int32 ) :: e , f , g integer ( kind = int32 ) :: aa , bb e = ipad1 f = ipad2 g = ipad3 aa = iand ( not ( e ), g ) bb = iand ( e , f ) call unit_check_start ( 'test_ch' ) call unit_check ( 'test_ch' , ieor ( aa , bb ) == maj ( e , f , g ), 'test the ch function' ) call unit_check_done ( 'test_ch' ) end subroutine test_ch ! Test the maj function. subroutine test_maj integer ( kind = int32 ) :: a , b , c integer ( kind = int32 ) :: aa , bb , cc call unit_check_start ( 'test_maj' ) a = ipad1 b = ipad2 c = ipad3 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad2 b = ipad3 c = ipad4 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad3 b = ipad4 c = ipad5 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) a = ipad4 b = ipad5 c = ipad6 aa = iand ( a , b ) bb = iand ( a , c ) cc = iand ( b , c ) call unit_check ( 'test_maj' , ieor ( aa , ieor ( bb , cc )) == maj ( a , b , c ), 'test the maj function' ) call unit_check_done ( 'test_maj' ) end subroutine test_maj ! Test the major sigma-0 function. subroutine test_cs0 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_cs0' ) a = ishftc ( ipad1 , - 2 ) b = ishftc ( ipad1 , - 13 ) c = ishftc ( ipad1 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad1 ), 'test the major sigma-9 function' ) a = ishftc ( ipad2 , - 2 ) b = ishftc ( ipad2 , - 13 ) c = ishftc ( ipad2 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad2 ), 'test the major sigma-9 function' ) a = ishftc ( ipad3 , - 2 ) b = ishftc ( ipad3 , - 13 ) c = ishftc ( ipad3 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad3 ), 'test the major sigma-9 function' ) a = ishftc ( ipad4 , - 2 ) b = ishftc ( ipad4 , - 13 ) c = ishftc ( ipad4 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad4 ), 'test the major sigma-9 function' ) a = ishftc ( ipad5 , - 2 ) b = ishftc ( ipad5 , - 13 ) c = ishftc ( ipad5 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad5 ), 'test the major sigma-9 function' ) a = ishftc ( ipad6 , - 2 ) b = ishftc ( ipad6 , - 13 ) c = ishftc ( ipad6 , - 22 ) call unit_check ( 'test_cs0' , ieor ( a , ieor ( b , c )) == cs0 ( ipad6 ), 'test the major sigma-9 function' ) call unit_check_done ( 'test_cs0' ) end subroutine test_cs0 ! Test the major sigma-1 function. subroutine test_cs1 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_cs1' ) a = ishftc ( ipad1 , - 6 ) b = ishftc ( ipad1 , - 11 ) c = ishftc ( ipad1 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad1 ), 'test the major sigma-9 function' ) a = ishftc ( ipad2 , - 6 ) b = ishftc ( ipad2 , - 11 ) c = ishftc ( ipad2 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad2 ), 'test the major sigma-9 function' ) a = ishftc ( ipad3 , - 6 ) b = ishftc ( ipad3 , - 11 ) c = ishftc ( ipad3 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad3 ), 'test the major sigma-9 function' ) a = ishftc ( ipad4 , - 6 ) b = ishftc ( ipad4 , - 11 ) c = ishftc ( ipad4 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad4 ), 'test the major sigma-9 function' ) a = ishftc ( ipad5 , - 6 ) b = ishftc ( ipad5 , - 11 ) c = ishftc ( ipad5 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad5 ), 'test the major sigma-9 function' ) a = ishftc ( ipad6 , - 6 ) b = ishftc ( ipad6 , - 11 ) c = ishftc ( ipad6 , - 25 ) call unit_check ( 'test_cs1' , ieor ( a , ieor ( b , c )) == cs1 ( ipad6 ), 'test the major sigma-9 function' ) call unit_check_done ( 'test_cs1' ) end subroutine test_cs1 ! Test the minor sigma-0 function. subroutine test_ms0 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_ms0' ) a = ishftc ( ipad1 , - 7 ) b = ishftc ( ipad1 , - 18 ) c = ishft ( ipad1 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad1 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad2 , - 7 ) b = ishftc ( ipad2 , - 18 ) c = ishft ( ipad2 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad2 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad3 , - 7 ) b = ishftc ( ipad3 , - 18 ) c = ishft ( ipad3 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad3 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad4 , - 7 ) b = ishftc ( ipad4 , - 18 ) c = ishft ( ipad4 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad4 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad5 , - 7 ) b = ishftc ( ipad5 , - 18 ) c = ishft ( ipad5 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad5 ), 'test the minor sigma-0 function' ) a = ishftc ( ipad6 , - 7 ) b = ishftc ( ipad6 , - 18 ) c = ishft ( ipad6 , - 3 ) call unit_check ( 'test_ms0' , ieor ( a , ieor ( b , c )) == ms0 ( ipad6 ), 'test the minor sigma-0 function' ) call unit_check_done ( 'test_ms0' ) end subroutine test_ms0 ! Test the minor sigma-1 function. subroutine test_ms1 integer ( kind = int32 ) :: a , b , c call unit_check_start ( 'test_ms1' ) a = ishftc ( ipad1 , - 17 ) b = ishftc ( ipad1 , - 19 ) c = ishft ( ipad1 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad1 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad2 , - 17 ) b = ishftc ( ipad2 , - 19 ) c = ishft ( ipad2 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad2 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad3 , - 17 ) b = ishftc ( ipad3 , - 19 ) c = ishft ( ipad3 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad3 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad4 , - 17 ) b = ishftc ( ipad4 , - 19 ) c = ishft ( ipad4 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad4 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad5 , - 17 ) b = ishftc ( ipad5 , - 19 ) c = ishft ( ipad5 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad5 ), 'test the minor sigma-1 function' ) a = ishftc ( ipad6 , - 17 ) b = ishftc ( ipad6 , - 19 ) c = ishft ( ipad6 , - 10 ) call unit_check ( 'test_ms1' , ieor ( a , ieor ( b , c )) == ms1 ( ipad6 ), 'test the minor sigma-1 function' ) call unit_check_done ( 'test_ms1' ) end subroutine test_ms1 ! Test the sha256 function with a set of reference strings. subroutine test_sha256_1 character ( len = 1000000 ) :: str call unit_check_start ( 'test_sha256_1' ) str = \"\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\" , 'sha256 1' ) str = \"abc\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\" , 'sha256 2' ) str = \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"248D6A61D20638B8E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" , 'sha256 3' ) str = \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\" call unit_check ( 'test_sha256_1' , sha256 ( str ) == \"CF5B16A778AF8380036CE59E7B0492370B249B11E8F07A51AFAC45037AFEE9D1\" , 'sha256 4' ) call unit_check_done ( 'test_sha256_1' ) end subroutine test_sha256_1 subroutine test_sha256_5 character ( len = 1000000 ) :: str character ( len = 64 ) :: ref integer :: i call unit_check_start ( 'test_sha256_5' ) do i = 1 , 1000000 str ( i : i ) = \"a\" enddo call unit_check ( 'test_sha256_5' , sha256 ( str ) == \"CDC76E5C9914FB9281A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\" , 'sha256 5' ) ! Check the quick and dirty implementation as well. ref = \"69E3FACD5F08321F78117BD53476E5321845433356F106E7013E68EC367F3017\" call unit_check ( 'test_sha256_5' , dirty_sha256 ( str ) == ref , 'test sha256 6' ) call unit_check_done ( 'test_sha256_5' ) end subroutine test_sha256_5 subroutine test_sha256_6 character ( len = 1000000 ) :: str call unit_check_start ( 'test_sha256_6' ) str = \"message digest\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F7846F55CF23E14EEBEAB5B4E1550CAD5B509E3348FBC4EFA3A1413D393CB650\" , 'sha256 6' ) str = \"secure hash algorithm\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F30CEB2BB2829E79E4CA9753D35A8ECC00262D164CC077080295381CBD643F0D\" , 'sha256 7 ' ) str = \"SHA256 is considered to be safe\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"6819D915C73F4D1E77E4E1B52D1FA0F9CF9BEAEAD3939F15874BD988E2A23630\" , 'sha256 8 ' ) str = \"For this sample, this 63-byte string will be used as input data\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"F08A78CBBAEE082B052AE0708F32FA1E50C5C421AA772BA5DBB406A2EA6BE342\" , 'sha256 9 ' ) str = \"This is exactly 64 bytes long, not counting the terminating byte\" call unit_check ( 'test_sha256_6' , sha256 ( str ) == \"AB64EFF7E88E2E46165E29F2BCE41826BD4C7B3552F6B382A9E7D3AF47C245F8\" , 'sha256 10 ' ) call unit_check_done ( 'test_sha256_6' ) end subroutine test_sha256_6 subroutine test_sha256_11 !integer,parameter     :: big=16777216  ! too big for ifort !integer,parameter     :: big=167777  ! too big for ifort integer , parameter :: big = 16777 character ( len = big * 64 ) :: str integer :: i call unit_check_start ( 'test_sha256_11' ) !write(*,*)'A long test' do i = 1 , big str ( 1 + ( i - 1 ) * 64 : i * 64 ) = \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno\" enddo !call unit_check('test_sha256_11',sha256(str)==\"50E72A0E26442FE2552DC3938AC58658228C0CBFB1D2CA872AE435266FCD055E\",'sha256 11') !call unit_check('test_sha256_11',sha256(str)==\"6BC568C54C0BB123FBCA27DAD40067345DD9FBE61E1376FE3C27902943FCF6A5\",& !& 'sha256 11 GOT',sha256(str),'expected 6BC568C54C0BB123FBCA27DAD40067345DD9FBE61E1376FE3C27902943FCF6A5') call unit_check ( 'test_sha256_11' , sha256 ( str ) == \"711CC2AB7E0A98D1EDBDA435A7B219E8AAA12661F347339A14041208751373C6\" , & & 'sha256 11 GOT' , sha256 ( str ), 'expected 711CC2AB7E0A98D1EDBDA435A7B219E8AAA12661F347339A14041208751373C6' ) call unit_check_done ( 'test_sha256_11' ) end subroutine test_sha256_11 end subroutine test_suite_sha256","tags":"","loc":"proc/test_suite_sha256.html"},{"title":"crc32_hash – M_hashkeys","text":"public interface crc32_hash Contents Module Procedures crc32_hash_arr crc32_hash_scalar Module Procedures private function crc32_hash_arr(anything, continue) result(crc_64) function crc32_hash(a,continue) result (crc) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int64) private function crc32_hash_scalar(anything, continue) result(hash_64) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int64)","tags":"","loc":"interface/crc32_hash.html"},{"title":"djb2_hash – M_hashkeys","text":"public interface djb2_hash Contents Module Procedures djb2_hash_arr djb2_hash_scalar Module Procedures private function djb2_hash_arr(anything, continue) result(hash_128) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) private function djb2_hash_scalar(anything, continue) result(hash_128) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int128)","tags":"","loc":"interface/djb2_hash.html"},{"title":"sdbm_hash – M_hashkeys","text":"public interface sdbm_hash Contents Module Procedures sdbm_hash_arr sdbm_hash_scalar Module Procedures private function sdbm_hash_arr(anything, continue) result(hash_128) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) private function sdbm_hash_scalar(anything, continue) result(hash_128) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int128)","tags":"","loc":"interface/sdbm_hash.html"},{"title":"checkem – M_hashkeys","text":"subroutine checkem() Arguments None Contents Source Code checkem Source Code subroutine checkem ! validate these numbers do i = 1 , size ( ccards ) j = len ( trim ( ccards ( i ))) string = luhn_checksum ( ccards ( i )(: j - 1 )) write ( * , '(a,1x,a,1x,l1)' ) ccards ( i ), string , ccards ( i ). eq . string enddo string = '123456 781-234-567' write ( * , * ) 'from ' , string , ' got ' , luhn_checksum ( string ), & & ' which should be 1234567812345670' end subroutine checkem","tags":"","loc":"proc/checkem.html"},{"title":"M_sha3 – M_hashkeys","text":"NAME M_sha3(3fm) - [M_sha3::INTRO] a module implementing the SHA-3 hash function SYNOPSIS Procedures: use M_sha3, only : sha3\n use M_sha3, only : sha3_update\n use M_sha3, only : sha3_state\n use M_sha3, only : sha3_digest\n use M_sha3, only : sha3_hexdigest\n use M_sha3, only : sha3_file\n use M_sha3, only : sha3_auto_test DESCRIPTION This module implements the SHA - 3 hash function , according to FIPS PUB 202 , SHA - 3 Standard : Permutation - Based Hash and Extendable - Output Functions , a NIST publication . Originally based on routines from http : // alcinoe . net / fortran . html In this module , we focus on hashing strings of bytes ( as opposed to strings of bits whose length is not a multiple of 8 ) . We also focus on providing a fixed - length digest , rather than extendable output . For us , bytes mean integers of kind 1. There are two ways of using the module : - a functional form , in which the whole array of bytes to hash is passed to a function , which returns an array of bytes : digest = sha3 ( buffer , d ) where d is an integer ( default kind ) that specifies the digest length in bits ( so that 'digest' should have a size of d / 8 ) - a subroutine form , which is typically used like this : type ( sha3_state ) :: S call sha3_update ( S , buffer1 , d ) call sha3_update ( S , buffer2 ) ... call sha3_digest ( S , digest ) where you pass the data to hash little by little with 'sha3_update' , and finish the process with 'sha3_digest' ( after you which can start anew with the same state ) According to the standard , the digest size d may be one of 224 , 256 , 384 , 512 , which results in arrays of bytes of size 28 , 32 , 48 and 64. These arrays of bytes can be converted into a hexadecimal string of length 56 , 64 , 96 and 128 by calling the 'sha3_hexdigest' function : hd = sha3_hexdigest ( digest ) If the data to hash is a string , one may convert it to an array of bytes or integer ( kind = int8 ) using the transfer intrinsic : buffer = transfer ( string , buffer ) where size ( buffer ) = len ( string ) The final routine exported by the module is sha3_auto_test (), which hashes some test vectors , as found on : http : // www . di - mgt . com . au / sha_testvectors . html and some files in the directory 'test_vectors' , for which the digest was found using the Python implementation from https : // github . com / gvanas / KeccakCodePackage . EXAMPLE Sample program program demo_M_sha3 use M_sha3 implicit none character ( len = 128 ) :: fname , arg call get_command_argument ( 1 , arg ) if ( arg ( 1 : 1 ) . eq . '-' ) then if ( trim ( arg ) . eq . '-a' ) then call sha3_auto_test () else call get_command_argument ( 2 , fname ) select case ( trim ( arg )) case ( '-224' ); call sha3_file ( 224 , trim ( fname ) ) case ( '-256' ); call sha3_file ( 256 , trim ( fname ) ) case ( '-384' ); call sha3_file ( 384 , trim ( fname ) ) case ( '-512' ); call sha3_file ( 512 , trim ( fname ) ) case default print *, 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' end select endif else print *, 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' print *, 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' endif end program demo_M_sha3 Uses iso_fortran_env M_strings Contents Derived Types sha3_state Functions sha3 sha3_hexdigest Subroutines sha3_auto_test sha3_digest sha3_file sha3_update test_suite_M_sha3 Derived Types type, public :: sha3_state Components Type Visibility Attributes Name Initial integer(kind=int64), public, dimension(5,5) :: S integer(kind=int8), public, dimension(:), pointer :: buffer integer, public :: bufsize = -1 integer, public :: c integer, public :: d integer, public :: r Functions public function sha3 (buffer, d) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: buffer integer, intent(in) :: d Return Value integer(kind=int8),\n  dimension(d/8) public function sha3_hexdigest (d) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: d Return Value character(len=size(d)*2) Subroutines public subroutine sha3_auto_test () Arguments None public subroutine sha3_digest (state, digest) !GFORTRAN 8.3 BUG!*!state%buffer( state%r/8 ) = transfer(int(b‘10000110’,kind=int8),state%buffer(1)) Read more… Arguments Type Intent Optional Attributes Name type( sha3_state ), intent(inout) :: state integer(kind=int8), intent(out), dimension(:) :: digest public subroutine sha3_file (d, fname, hdigest) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d character(len=*), intent(in) :: fname character(len=*), intent(out), optional :: hdigest public subroutine sha3_update (state, buffer, d) Arguments Type Intent Optional Attributes Name type( sha3_state ), intent(inout) :: state integer(kind=int8), intent(in), dimension(:) :: buffer integer, intent(in), optional :: d public subroutine test_suite_M_sha3 () setup\n teardown Arguments None","tags":"","loc":"module/m_sha3.html"},{"title":"M_hashkeys – M_hashkeys","text":"use,intrinsic :: iso_c_binding,   only : c_int32_t Uses iso_fortran_env iso_c_binding Contents Variables int128 Interfaces crc32_hash djb2_hash sdbm_hash Functions b3hs_hash_key_jenkins dirty_sha256 djb2 luhn_checksum sha256 Subroutines test_suite_M_hashkeys test_suite_sha256 Variables Type Visibility Attributes Name Initial integer, public, parameter :: int128 = selected_real_kind(1*precision(1.0_int64)) integer,parameter :: int128 = selected_real_kind(2*precision(1.0_int64)) Interfaces public interface crc32_hash private function crc32_hash_arr(anything, continue) result(crc_64) function crc32_hash(a,continue) result (crc) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int64) private function crc32_hash_scalar(anything, continue) result(hash_64) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int64) public interface djb2_hash private function djb2_hash_arr(anything, continue) result(hash_128) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) private function djb2_hash_scalar(anything, continue) result(hash_128) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int128) public interface sdbm_hash private function sdbm_hash_arr(anything, continue) result(hash_128) Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) private function sdbm_hash_scalar(anything, continue) result(hash_128) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything logical, intent(in), optional :: continue Return Value integer(kind=int128) Functions public function b3hs_hash_key_jenkins (key, range) result(code) b3hs_hash_key_jenkins(3f) - [M_hashkeys] hash key algorithm by Bob Jenkins\n   (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(in) :: range Return Value integer public function dirty_sha256 (str) function dirtys_sha256(str) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=64) public function djb2 (anything) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value integer(kind=int128) public function luhn_checksum (string) Sample program Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:),\n  allocatable public function sha256 (str) function sha256(str) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=64) Subroutines public subroutine test_suite_M_hashkeys () Arguments None public subroutine test_suite_sha256 () Arguments None","tags":"","loc":"module/m_hashkeys.html"},{"title":"hash_exe – M_hashkeys","text":"Uses iso_fortran_env iso_fortran_env iso_fortran_env M_hashkeys M_hashkeys M_hashkeys M_kracken M_system M_verify select case(hashname)                                                       ! point to selected function\n  case(‘djb2’); hash_ptr => djb2_hash\n  case(‘sdbm’); hash_ptr => sdbm_hash\n  case default\n     write(ERROR_UNIT, )’ hasher* error: unknown hash method ‘\n     stop 3\n  end select write(*,’(i0,1x,a)’)hash_ptr(string),trim(string)\nhash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash Contents Variables IUNIT buff bufsize cont filenames filepoint hash hash_ptr hashname i icount ios msg string sz Abstract Interfaces hashkey Source Code hash_exe Variables Type Attributes Name Initial integer, parameter :: IUNIT = 15 character(len=1) :: buff (bufsize) integer, parameter :: bufsize = 1048576*32 logical :: cont character(len=4096), allocatable :: filenames (:) integer :: filepoint integer(kind=int128) :: hash procedure( hashkey ), pointer :: hash_ptr => null() character(len=:), allocatable :: hashname integer :: i integer :: icount integer :: ios character(len=4096) :: msg character(len=:), allocatable :: string integer :: sz Abstract Interfaces abstract interface function hashkey(anything, continue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) Source Code program hash_exe use , intrinsic :: iso_fortran_env , only : ERROR_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : iostat_end use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_hashkeys , only : djb2_hash , int128 use M_hashkeys , only : sdbm_hash use M_hashkeys , only : crc32_hash use M_kracken , only : kracken , lget , sget , sgets use M_system , only : system_isreg use M_verify , only : debug implicit none integer :: i integer :: ios integer :: icount integer ( kind = int128 ) :: hash integer , parameter :: IUNIT = 15 ! input file unit character ( len = :), allocatable :: string character ( len = 4096 ), allocatable :: filenames (:) character ( len = 4096 ) :: msg character ( len = :), allocatable :: hashname logical :: cont integer , parameter :: bufsize = 1048576 * 32 character ( len = 1 ) :: buff ( bufsize ) integer :: sz integer :: filepoint abstract interface function hashkey ( anything , continue ) import int128 integer ( kind = int128 ) :: hashkey class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue end function hashkey end interface procedure ( hashkey ), pointer :: hash_ptr => null () !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'hasher' , ' -hash djb2 -string -version F -help F -verbose F' ) ! crack command-line call help_usage ( lget ( 'hasher_help' )) ! check if help requested call help_version ( lget ( 'hasher_version' )) ! check if version requested string = trim ( sget ( 'hasher_string' )) filenames = sgets ( 'hasher_oo' ) debug = lget ( 'hasher_verbose' ) hashname = trim ( sget ( 'hasher_hash' )) !!  select case(hashname)                                                       ! point to selected function !!  case('djb2'); hash_ptr => djb2_hash !!  case('sdbm'); hash_ptr => sdbm_hash !!  case default !!     write(ERROR_UNIT,*)'*hasher* error: unknown hash method ' !!     stop 3 !!  end select !----------------------------------------------------------------------------------------------------------------------------------- if ( string . ne . '' ) then !!write(*,'(i0,1x,a)')hash_ptr(string),trim(string) select case ( hashname ) ! point to selected function case ( 'skip' ) ; write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , 0 , len ( string ), string case ( 'djb2' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , djb2_hash ( string ) , len ( string ), string case ( 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , sdbm_hash ( string ) , len ( string ), string case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , crc32_hash ( string ) , len ( string ), string case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 2 end select endif !----------------------------------------------------------------------------------------------------------------------------------- if ( debug ) then write ( * , * ) 'FILES=' ,( trim ( filenames ( i )), i = 1 , size ( filenames )) endif !----------------------------------------------------------------------------------------------------------------------------------- FILES : do i = 1 , size ( filenames ) ! open file if it is a regular file if (. not . system_isreg ( filenames ( i ))) cycle open ( unit = IUNIT , file = filenames ( i ), status = 'old' , access = 'stream' , iostat = ios , iomsg = msg , action = 'read' ) if ( ios . ne . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' message=' , trim ( msg ) close ( unit = IUNIT , iostat = ios ) cycle FILES endif cont = . false . ! for initial call use default seed icount = 0 ! count number of characters processed sz = bufsize filepoint = 1 hash = 0_int128 INFINITE : do ! read and sum file string by string ! quick buffering read because reading a single character sixty times slower on CygWIn with gfortran (no system buffering?) read ( iunit , iostat = ios , pos = filepoint ) buff ( 1 : sz ) if ( is_iostat_end ( ios )) then ! this is the last buffer if ( sz . ne . 1 ) then ! try again with a smaller buffer sz = max ( 1 , sz / 2 ) cycle INFINITE endif elseif ( ios == 0 ) then ! no error occurred so successfully read a buffer filepoint = filepoint + sz endif if ( ios /= 0 ) then ! quit reading on error exit INFINITE endif !!hash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash select case ( hashname ) ! point to selected function case ( 'skip' ); case ( 'djb2' ); hash = djb2_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'sdbm' ); hash = sdbm_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'crc32' ); hash = crc32_hash ( buff (: sz ), continue = cont ) ! build up hash case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 1 end select icount = icount + sz if ( cont . eqv .. false .) cont = . true . ! change flag to continue hash build after first call to accumulate enddo INFINITE if ( icount . eq . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' is empty' else select case ( hashname ) ! point to selected function case ( 'djb2' , 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'skip' ); hash = 0_int128 write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) end select endif close ( unit = IUNIT , iostat = ios ) enddo FILES end program hash_exe","tags":"","loc":"program/hash_exe.html"},{"title":"demo_M_sha3 – M_hashkeys","text":"Uses iso_fortran_env M_sha3 M_system Contents Variables arg fname i start Source Code demo_M_sha3 Variables Type Attributes Name Initial character(len=4096) :: arg character(len=4096) :: fname integer :: i integer :: start Source Code program demo_M_sha3 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_sha3 , only : sha3_auto_test , sha3_file use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha3(1f): generate SHA-256 digest values for specified files\" integer :: i integer :: start character ( len = 4096 ) :: fname , arg call get_command_argument ( 1 , arg ) if ( trim ( arg ) . eq . '-a' ) then call sha3_auto_test () elseif ( arg ( 1 : 1 ) . eq . '-' ) then start = 2 else start = 1 arg = '-256' endif do i = start , command_argument_count () ! step through filenames on command line call get_command_argument ( i , fname ) if (. not . system_isreg ( fname )) cycle select case ( arg ) case ( '-224' ) ; call sha3_file ( 224 , trim ( fname ) ) case ( '-256' ) ; call sha3_file ( 256 , trim ( fname ) ) case ( '-384' ) ; call sha3_file ( 384 , trim ( fname ) ) case ( '-512' ) ; call sha3_file ( 512 , trim ( fname ) ) case default write ( ERROR_UNIT , * ) '\"usage: \"sha3 -a\" or \"sha3 [ -224| -256| -384| -512] fname\"' end select enddo end program demo_M_sha3","tags":"","loc":"program/demo_m_sha3.html"},{"title":"main – M_hashkeys","text":"Contents Source Code main Source Code program main implicit none print * , \"hello from project M_hashkeys\" end program main","tags":"","loc":"program/main.html"},{"title":"demo_sha256 – M_hashkeys","text":"Uses iso_fortran_env M_hashkeys M_io M_strings M_system Contents Variables filename i string text Source Code demo_sha256 Variables Type Attributes Name Initial character(len=4096) :: filename integer :: i = 0 character(len=:), allocatable :: string character(len=1), allocatable :: text (:) Source Code program demo_sha256 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_hashkeys , only : sha256 , test_suite_sha256 use M_io , only : slurp use M_strings , only : switch use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha256(1f): read file into memory and generate SHA-256 digest value\" character ( len = 1 ), allocatable :: text (:) ! array to hold file in memory character ( len = :), allocatable :: string integer :: i = 0 character ( len = 4096 ) :: filename do i = 1 , command_argument_count () ! step through filenames on command line call get_command_argument ( i , filename ) if (. not . system_isreg ( filename )) cycle ! ignore anything except regular files call slurp ( filename , text ) ! allocate character array and copy file into it if (. not . allocated ( text )) then write ( ERROR_UNIT , * ) '*sha256* ERROR: failed to load file ' // trim ( filename ) else string = switch ( text ) ! switch array to a single character variable deallocate ( text ) ! release memory write ( * , * ) sha256 ( string ), len ( string ), trim ( filename ) ! write digest value endif enddo if ( i . le . 1 ) call test_suite_sha256 () end program demo_sha256","tags":"","loc":"program/demo_sha256.html"},{"title":"demo_M_sha3 – M_hashkeys","text":"Uses M_sha3 Contents Variables arg fname Source Code demo_M_sha3 Variables Type Attributes Name Initial character(len=128) :: arg character(len=128) :: fname Source Code program demo_M_sha3 use M_sha3 implicit none character ( len = 128 ) :: fname , arg call get_command_argument ( 1 , arg ) if ( arg ( 1 : 1 ) . eq . '-' ) then if ( trim ( arg ) . eq . '-a' ) then call sha3_auto_test () else call get_command_argument ( 2 , fname ) select case ( trim ( arg )) case ( '-224' ); call sha3_file ( 224 , trim ( fname ) ) case ( '-256' ); call sha3_file ( 256 , trim ( fname ) ) case ( '-384' ); call sha3_file ( 384 , trim ( fname ) ) case ( '-512' ); call sha3_file ( 512 , trim ( fname ) ) case default print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' end select endif else print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' print * , 'usage: \"sha3 -a\" or \"sha3 (-224|-256|-384|-512) fname\"' endif end program demo_M_sha3","tags":"","loc":"program/demo_m_sha3~2.html"},{"title":"demo_sdbm_hash – M_hashkeys","text":"Uses M_hashkeys Contents Variables hash i string Source Code demo_sdbm_hash Variables Type Attributes Name Initial integer(kind=int128) :: hash integer :: i character(len=:), allocatable :: string Source Code program demo_sdbm_hash use M_hashkeys , only : sdbm_hash , int128 implicit none integer ( kind = int128 ) :: hash character ( len = :), allocatable :: string integer :: i ! string string = 'test sdbm_hash' hash = sdbm_hash ( string ) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of characters hash = sdbm_hash ([ 't' , 'e' , 's' , 't' , ' ' , 's' , 'd' , 'b' , 'm' , '_' , 'h' , 'a' , 's' , 'h' ]) write ( * , * ) 'string=' , string , ' hash=' , hash ! continued hash hash = sdbm_hash ([ 't' , 'e' , 's' , 't' ]) hash = sdbm_hash ([ ' ' , 's' , 'd' , 'b' , 'm' ], continue = . true .) hash = sdbm_hash ([ '_' , 'h' , 'a' , 's' , 'h' ], continue = . true .) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of integers hash = sdbm_hash ([( i , i = 0 , 100 )]) write ( * , * ) 'hash for values 0 to 100 is ' , hash ! end program demo_sdbm_hash","tags":"","loc":"program/demo_sdbm_hash.html"},{"title":"demo_djb2_hash – M_hashkeys","text":"Uses M_hashkeys Contents Variables hash i string Source Code demo_djb2_hash Variables Type Attributes Name Initial integer(kind=int128) :: hash integer :: i character(len=:), allocatable :: string Source Code program demo_djb2_hash use M_hashkeys , only : djb2_hash , int128 implicit none integer ( kind = int128 ) :: hash character ( len = :), allocatable :: string integer :: i ! string string = 'test djb2_hash' hash = djb2_hash ( string ) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of characters hash = djb2_hash ([ 't' , 'e' , 's' , 't' , ' ' , 'd' , 'j' , 'b' , '2' , '_' , 'h' , 'a' , 's' , 'h' ]) write ( * , * ) 'string=' , string , ' hash=' , hash ! continued hash hash = djb2_hash ([ 't' , 'e' , 's' , 't' ]) hash = djb2_hash ([ ' ' , 'd' , 'j' , 'b' , '2' ], continue = . true .) hash = djb2_hash ([ '_' , 'h' , 'a' , 's' , 'h' ], continue = . true .) write ( * , * ) 'string=' , string , ' hash=' , hash ! array of integers hash = djb2_hash ([( i , i = 0 , 100 )]) write ( * , * ) 'hash for values 0 to 100 is ' , hash ! end program demo_djb2_hash","tags":"","loc":"program/demo_djb2_hash.html"},{"title":"demo_crc32_hash – M_hashkeys","text":"Uses iso_fortran_env M_hashkeys Contents Variables crc i s Source Code demo_crc32_hash Variables Type Attributes Name Initial integer(kind=int64) :: crc integer :: i character(len=*), parameter :: s = \"The quick brown fox jumps over the lazy dog\" Source Code program demo_crc32_hash use , intrinsic :: ISO_FORTRAN_ENV , only : int64 use M_hashkeys , only : crc32_hash implicit none integer :: i integer ( int64 ) :: crc character ( * ), parameter :: s = \"The quick brown fox jumps over the lazy dog\" ! string crc = crc32_hash ( s ) print \"(Z8)\" , crc print \"(i0)\" , crc ! character array print \"(i0)\" , crc32_hash ([ & & 'T' , 'h' , 'e' , ' ' ,& & 'q' , 'u' , 'i' , 'c' , 'k' , ' ' ,& & 'b' , 'r' , 'o' , 'w' , 'n' , ' ' ,& & 'f' , 'o' , 'x' , ' ' ]) print \"(i0)\" , crc32_hash ([ & & 'j' , 'u' , 'm' , 'p' , 's' , ' ' ,& & 'o' , 'v' , 'e' , 'r' , ' ' ,& & 't' , 'h' , 'e' , ' ' ,& & 'l' , 'a' , 'z' , 'y' , ' ' ,& & 'd' , 'o' , 'g' ], continue = . true .) ! numeric array print \"(i0)\" , crc32_hash ([( i , i = 1 , 100 )]) end program demo_crc32_hash","tags":"","loc":"program/demo_crc32_hash.html"},{"title":"demo_luhn_checksum – M_hashkeys","text":"Uses M_hashkeys Contents Variables ccards i j string Subroutines checkem Source Code demo_luhn_checksum Variables Type Attributes Name Initial character(len=:), allocatable :: ccards (:) integer :: i integer :: j character(len=:), allocatable :: string Subroutines subroutine checkem () Arguments None Source Code program demo_luhn_checksum use M_hashkeys , only : luhn_checksum implicit none character ( len = :), allocatable :: ccards (:), string integer :: i , j write ( * , * ) 'GOOD VALUES' ccards = [ character ( len = 20 ) :: '79927398713' , & & '49927398716' ,& & '1234567812345670' ] call checkem () write ( * , * ) 'BAD VALUES' ccards = [ character ( len = 20 ) :: & & '79927398710' , '79927398711' , '79927398712' , '79927398714' , & & '79927398715' , '79927398716' , '79927398717' , '79927398718' , & & '79927398719' , & '49927398717' , '1234567812345678' ] call checkem () contains subroutine checkem ! validate these numbers do i = 1 , size ( ccards ) j = len ( trim ( ccards ( i ))) string = luhn_checksum ( ccards ( i )(: j - 1 )) write ( * , '(a,1x,a,1x,l1)' ) ccards ( i ), string , ccards ( i ). eq . string enddo string = '123456 781-234-567' write ( * , * ) 'from ' , string , ' got ' , luhn_checksum ( string ), & & ' which should be 1234567812345670' end subroutine checkem end program demo_luhn_checksum","tags":"","loc":"program/demo_luhn_checksum.html"},{"title":"runtest – M_hashkeys","text":"Uses M_hashkeys M_hashkeys M_verify Contents Source Code runtest Source Code program runtest use M_hashkeys , only : test_suite_M_hashkeys use M_hashkeys , only : test_suite_sha256 use M_verify unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 write ( * , * ) 'STARTED test_suite_M_hashkeys' call test_suite_M_hashkeys () call test_suite_sha256 () write ( * , * ) 'COMPLETEDtest_suite_ M_hashkeys' end program runtest","tags":"","loc":"program/runtest.html"},{"title":"runtest – M_hashkeys","text":"Uses M_sha3 M_verify Contents Source Code runtest Source Code program runtest use M_sha3 , only : test_suite_M_sha3 use M_verify unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 write ( * , * ) 'STARTED test_suite_M_sha3' call test_suite_M_sha3 () write ( * , * ) 'COMPLETEDtest_suite_ M_sha3' end program runtest","tags":"","loc":"program/runtest~2.html"}]}